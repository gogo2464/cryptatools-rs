window.SIDEBAR_ITEMS = {"fn":[["abort","Aborts the execution of the process."],["add_with_overflow","Performs checked integer addition."],["arith_offset","Calculates the offset from a pointer, potentially wrapping."],["assert_inhabited","A guard for unsafe functions that cannot ever be executed if `T` is uninhabited: This will statically either panic, or do nothing."],["assert_uninit_valid","A guard for unsafe functions that cannot ever be executed if `T` has invalid bit patterns: This will statically either panic, or do nothing."],["assert_zero_valid","A guard for unsafe functions that cannot ever be executed if `T` does not permit zero-initialization: This will statically either panic, or do nothing."],["assume","Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined."],["atomic_and_acqrel","Bitwise and with the current value, returning the previous value."],["atomic_and_acquire","Bitwise and with the current value, returning the previous value."],["atomic_and_relaxed","Bitwise and with the current value, returning the previous value."],["atomic_and_release","Bitwise and with the current value, returning the previous value."],["atomic_and_seqcst","Bitwise and with the current value, returning the previous value."],["atomic_cxchg_acqrel_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_acqrel_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_acqrel_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_acquire_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_acquire_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_acquire_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_relaxed_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_relaxed_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_relaxed_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_release_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_release_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_release_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_seqcst_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_seqcst_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchg_seqcst_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_acqrel_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_acqrel_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_acqrel_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_acquire_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_acquire_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_acquire_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_relaxed_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_relaxed_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_relaxed_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_release_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_release_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_release_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_seqcst_acquire","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_seqcst_relaxed","Stores a value if the current value is the same as the `old` value."],["atomic_cxchgweak_seqcst_seqcst","Stores a value if the current value is the same as the `old` value."],["atomic_fence_acqrel","An atomic fence."],["atomic_fence_acquire","An atomic fence."],["atomic_fence_release","An atomic fence."],["atomic_fence_seqcst","An atomic fence."],["atomic_load_acquire","Loads the current value of the pointer."],["atomic_load_relaxed","Loads the current value of the pointer."],["atomic_load_seqcst","Loads the current value of the pointer."],["atomic_load_unordered",""],["atomic_max_acqrel","Maximum with the current value using a signed comparison."],["atomic_max_acquire","Maximum with the current value using a signed comparison."],["atomic_max_relaxed","Maximum with the current value."],["atomic_max_release","Maximum with the current value using a signed comparison."],["atomic_max_seqcst","Maximum with the current value using a signed comparison."],["atomic_min_acqrel","Minimum with the current value using a signed comparison."],["atomic_min_acquire","Minimum with the current value using a signed comparison."],["atomic_min_relaxed","Minimum with the current value using a signed comparison."],["atomic_min_release","Minimum with the current value using a signed comparison."],["atomic_min_seqcst","Minimum with the current value using a signed comparison."],["atomic_nand_acqrel","Bitwise nand with the current value, returning the previous value."],["atomic_nand_acquire","Bitwise nand with the current value, returning the previous value."],["atomic_nand_relaxed","Bitwise nand with the current value, returning the previous value."],["atomic_nand_release","Bitwise nand with the current value, returning the previous value."],["atomic_nand_seqcst","Bitwise nand with the current value, returning the previous value."],["atomic_or_acqrel","Bitwise or with the current value, returning the previous value."],["atomic_or_acquire","Bitwise or with the current value, returning the previous value."],["atomic_or_relaxed","Bitwise or with the current value, returning the previous value."],["atomic_or_release","Bitwise or with the current value, returning the previous value."],["atomic_or_seqcst","Bitwise or with the current value, returning the previous value."],["atomic_singlethreadfence_acqrel","A compiler-only memory barrier."],["atomic_singlethreadfence_acquire","A compiler-only memory barrier."],["atomic_singlethreadfence_release","A compiler-only memory barrier."],["atomic_singlethreadfence_seqcst","A compiler-only memory barrier."],["atomic_store_relaxed","Stores the value at the specified memory location."],["atomic_store_release","Stores the value at the specified memory location."],["atomic_store_seqcst","Stores the value at the specified memory location."],["atomic_store_unordered",""],["atomic_umax_acqrel","Maximum with the current value using an unsigned comparison."],["atomic_umax_acquire","Maximum with the current value using an unsigned comparison."],["atomic_umax_relaxed","Maximum with the current value using an unsigned comparison."],["atomic_umax_release","Maximum with the current value using an unsigned comparison."],["atomic_umax_seqcst","Maximum with the current value using an unsigned comparison."],["atomic_umin_acqrel","Minimum with the current value using an unsigned comparison."],["atomic_umin_acquire","Minimum with the current value using an unsigned comparison."],["atomic_umin_relaxed","Minimum with the current value using an unsigned comparison."],["atomic_umin_release","Minimum with the current value using an unsigned comparison."],["atomic_umin_seqcst","Minimum with the current value using an unsigned comparison."],["atomic_xadd_acqrel","Adds to the current value, returning the previous value."],["atomic_xadd_acquire","Adds to the current value, returning the previous value."],["atomic_xadd_relaxed","Adds to the current value, returning the previous value."],["atomic_xadd_release","Adds to the current value, returning the previous value."],["atomic_xadd_seqcst","Adds to the current value, returning the previous value."],["atomic_xchg_acqrel","Stores the value at the specified memory location, returning the old value."],["atomic_xchg_acquire","Stores the value at the specified memory location, returning the old value."],["atomic_xchg_relaxed","Stores the value at the specified memory location, returning the old value."],["atomic_xchg_release","Stores the value at the specified memory location, returning the old value."],["atomic_xchg_seqcst","Stores the value at the specified memory location, returning the old value."],["atomic_xor_acqrel","Bitwise xor with the current value, returning the previous value."],["atomic_xor_acquire","Bitwise xor with the current value, returning the previous value."],["atomic_xor_relaxed","Bitwise xor with the current value, returning the previous value."],["atomic_xor_release","Bitwise xor with the current value, returning the previous value."],["atomic_xor_seqcst","Bitwise xor with the current value, returning the previous value."],["atomic_xsub_acqrel","Subtract from the current value, returning the previous value."],["atomic_xsub_acquire","Subtract from the current value, returning the previous value."],["atomic_xsub_relaxed","Subtract from the current value, returning the previous value."],["atomic_xsub_release","Subtract from the current value, returning the previous value."],["atomic_xsub_seqcst","Subtract from the current value, returning the previous value."],["bitreverse","Reverses the bits in an integer type `T`."],["black_box","See documentation of `std::hint::black_box` for details."],["breakpoint","Executes a breakpoint trap, for inspection by a debugger."],["bswap","Reverses the bytes in an integer type `T`."],["caller_location","Gets a reference to a static `Location` indicating where it was called."],["ceilf32","Returns the smallest integer greater than or equal to an `f32`."],["ceilf64","Returns the smallest integer greater than or equal to an `f64`."],["const_allocate","Allocates a block of memory at compile time. At runtime, just returns a null pointer."],["const_deallocate","Deallocates a memory which allocated by `intrinsics::const_allocate` at compile time. At runtime, does nothing."],["const_eval_select","Selects which function to call depending on the context."],["copy","Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source and destination may overlap."],["copy_nonoverlapping","Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source and destination must not overlap."],["copysignf32","Copies the sign from `y` to `x` for `f32` values."],["copysignf64","Copies the sign from `y` to `x` for `f64` values."],["cosf32","Returns the cosine of an `f32`."],["cosf64","Returns the cosine of an `f64`."],["ctlz","Returns the number of leading unset bits (zeroes) in an integer type `T`."],["ctlz_nonzero","Like `ctlz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`."],["ctpop","Returns the number of bits set in an integer type `T`"],["cttz","Returns the number of trailing unset bits (zeroes) in an integer type `T`."],["cttz_nonzero","Like `cttz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`."],["discriminant_value","Returns the value of the discriminant for the variant in ‘v’; if `T` has no discriminant, returns `0`."],["drop_in_place",""],["exact_div","Performs an exact division, resulting in undefined behavior where `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`"],["exp2f32","Returns 2 raised to the power of an `f32`."],["exp2f64","Returns 2 raised to the power of an `f64`."],["expf32","Returns the exponential of an `f32`."],["expf64","Returns the exponential of an `f64`."],["fabsf32","Returns the absolute value of an `f32`."],["fabsf64","Returns the absolute value of an `f64`."],["fadd_fast","Float addition that allows optimizations based on algebraic rules. May assume inputs are finite."],["fdiv_fast","Float division that allows optimizations based on algebraic rules. May assume inputs are finite."],["float_to_int_unchecked","Convert with LLVM’s fptoui/fptosi, which may return undef for values out of range (https://github.com/rust-lang/rust/issues/10184)"],["floorf32","Returns the largest integer less than or equal to an `f32`."],["floorf64","Returns the largest integer less than or equal to an `f64`."],["fmaf32","Returns `a * b + c` for `f32` values."],["fmaf64","Returns `a * b + c` for `f64` values."],["fmul_fast","Float multiplication that allows optimizations based on algebraic rules. May assume inputs are finite."],["forget","Moves a value out of scope without running drop glue."],["frem_fast","Float remainder that allows optimizations based on algebraic rules. May assume inputs are finite."],["fsub_fast","Float subtraction that allows optimizations based on algebraic rules. May assume inputs are finite."],["likely","Hints to the compiler that branch condition is likely to be true. Returns the value passed to it."],["log10f32","Returns the base 10 logarithm of an `f32`."],["log10f64","Returns the base 10 logarithm of an `f64`."],["log2f32","Returns the base 2 logarithm of an `f32`."],["log2f64","Returns the base 2 logarithm of an `f64`."],["logf32","Returns the natural logarithm of an `f32`."],["logf64","Returns the natural logarithm of an `f64`."],["maxnumf32","Returns the maximum of two `f32` values."],["maxnumf64","Returns the maximum of two `f64` values."],["min_align_of","The minimum alignment of a type."],["min_align_of_val","The required alignment of the referenced value."],["minnumf32","Returns the minimum of two `f32` values."],["minnumf64","Returns the minimum of two `f64` values."],["mul_with_overflow","Performs checked integer multiplication"],["nearbyintf32","Returns the nearest integer to an `f32`."],["nearbyintf64","Returns the nearest integer to an `f64`."],["needs_drop","Returns `true` if the actual type given as `T` requires drop glue; returns `false` if the actual type provided for `T` implements `Copy`."],["nontemporal_store","Emits a `!nontemporal` store according to LLVM (see their docs). Probably will never become stable."],["offset","Calculates the offset from a pointer."],["powf32","Raises an `f32` to an `f32` power."],["powf64","Raises an `f64` to an `f64` power."],["powif32","Raises an `f32` to an integer power."],["powif64","Raises an `f64` to an integer power."],["pref_align_of","The preferred alignment of a type."],["prefetch_read_data","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics."],["prefetch_read_instruction","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics."],["prefetch_write_data","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics."],["prefetch_write_instruction","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics."],["ptr_guaranteed_cmp","See documentation of `<*const T>::guaranteed_eq` for details. Returns `2` if the result is unknown. Returns `1` if the pointers are guaranteed equal Returns `0` if the pointers are guaranteed inequal"],["ptr_mask","Masks out bits of the pointer according to a mask."],["ptr_offset_from","See documentation of `<*const T>::offset_from` for details."],["ptr_offset_from_unsigned","See documentation of `<*const T>::sub_ptr` for details."],["raw_eq","Determines whether the raw bytes of the two values are equal."],["rintf32","Returns the nearest integer to an `f32`. May raise an inexact floating-point exception if the argument is not an integer."],["rintf64","Returns the nearest integer to an `f64`. May raise an inexact floating-point exception if the argument is not an integer."],["rotate_left","Performs rotate left."],["rotate_right","Performs rotate right."],["roundf32","Returns the nearest integer to an `f32`. Rounds half-way cases away from zero."],["roundf64","Returns the nearest integer to an `f64`. Rounds half-way cases away from zero."],["rustc_peek","Magic intrinsic that derives its meaning from attributes attached to the function."],["saturating_add","Computes `a + b`, saturating at numeric bounds."],["saturating_sub","Computes `a - b`, saturating at numeric bounds."],["sinf32","Returns the sine of an `f32`."],["sinf64","Returns the sine of an `f64`."],["size_of","The size of a type in bytes."],["size_of_val","The size of the referenced value in bytes."],["sqrtf32","Returns the square root of an `f32`"],["sqrtf64","Returns the square root of an `f64`"],["sub_with_overflow","Performs checked integer subtraction"],["transmute","Reinterprets the bits of a value of one type as another type."],["truncf32","Returns the integer part of an `f32`."],["truncf64","Returns the integer part of an `f64`."],["try","Rust’s “try catch” construct which invokes the function pointer `try_fn` with the data pointer `data`."],["type_id","Gets an identifier which is globally unique to the specified type. This function will return the same value for a type regardless of whichever crate it is invoked in."],["type_name","Gets a static string slice containing the name of a type."],["unaligned_volatile_load","Performs a volatile load from the `src` pointer The pointer is not required to be aligned."],["unaligned_volatile_store","Performs a volatile store to the `dst` pointer. The pointer is not required to be aligned."],["unchecked_add","Returns the result of an unchecked addition, resulting in undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`."],["unchecked_div","Performs an unchecked division, resulting in undefined behavior where `y == 0` or `x == T::MIN && y == -1`"],["unchecked_mul","Returns the result of an unchecked multiplication, resulting in undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`."],["unchecked_rem","Returns the remainder of an unchecked division, resulting in undefined behavior when `y == 0` or `x == T::MIN && y == -1`"],["unchecked_shl","Performs an unchecked left shift, resulting in undefined behavior when `y < 0` or `y >= N`, where N is the width of T in bits."],["unchecked_shr","Performs an unchecked right shift, resulting in undefined behavior when `y < 0` or `y >= N`, where N is the width of T in bits."],["unchecked_sub","Returns the result of an unchecked subtraction, resulting in undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`."],["unlikely","Hints to the compiler that branch condition is likely to be false. Returns the value passed to it."],["unreachable","Informs the optimizer that this point in the code is not reachable, enabling further optimizations."],["variant_count","Returns the number of variants of the type `T` cast to a `usize`; if `T` has no variants, returns `0`. Uninhabited variants will be counted."],["volatile_copy_memory","Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with a size of `count * size_of::<T>()` and an alignment of `min_align_of::<T>()`"],["volatile_copy_nonoverlapping_memory","Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`"],["volatile_load","Performs a volatile load from the `src` pointer."],["volatile_set_memory","Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a size of `count * size_of::<T>()` and an alignment of `min_align_of::<T>()`."],["volatile_store","Performs a volatile store to the `dst` pointer."],["vtable_align","`ptr` must point to a vtable. The intrinsic will return the alignment stored in that vtable."],["vtable_size","`ptr` must point to a vtable. The intrinsic will return the size stored in that vtable."],["wrapping_add","Returns (a + b) mod 2N, where N is the width of T in bits."],["wrapping_mul","Returns (a * b) mod 2N, where N is the width of T in bits."],["wrapping_sub","Returns (a - b) mod 2N, where N is the width of T in bits."],["write_bytes","Sets `count * size_of::<T>()` bytes of memory starting at `dst` to `val`."]],"mod":[["mir","Rustc internal tooling for hand-writing MIR."]]};