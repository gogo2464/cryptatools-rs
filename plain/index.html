<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A small Rust library that allows users to interpret arrays of bytes as certain kinds of structures safely."><title>plain - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../static.files/ayu-be46fdc453a55015.css"><script src="../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../plain/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../plain/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate plain</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.2.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">plain</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/plain/lib.rs.html#1-158">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A small Rust library that allows users to interpret arrays of bytes
as certain kinds of structures safely.</p>
<p>This crate provides an unsafe trait <a href="trait.Plain.html"><code>Plain</code></a>, which the user
of the crate uses to mark types for which operations of this library are safe.
See <a href="trait.Plain.html"><code>Plain</code></a> for the contractual obligation.</p>
<p>Other than that, everything else in this crate is perfectly safe to use as long
as the <code>Plain</code> trait is not implemented on inadmissible types (similar to how
<code>Send</code> and <code>Sync</code> in the standard library work).</p>
<h2 id="purpose"><a href="#purpose">Purpose</a></h2>
<p>In low level systems development, it is sometimes necessary to
interpret locations in memory as data structures. Functions of
this crate serve to avoid pitfalls associated with that, without
having to resort to big, full-featured (de)serialization libraries.</p>
<p>On the other hand, this crate contains no provisions when it comes
to handling differences in encoding and byte ordering between
platforms. As such, it is entirely unsuitable for processing
external data such as file contents or network packets.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>To start using the crate, simply do <code>extern crate plain;</code>.</p>
<p>If you want your plain types to have methods from this crate, also include <code>use plain.Plain;</code>.</p>
<p>Then it’s just a matter of marking the right types and using them.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">extern crate </span>plain;
<span class="kw">use </span>plain::Plain;
<span class="kw">use </span>std::mem;


<span class="attr">#[repr(C)]
#[derive(Default)]
</span><span class="kw">struct </span>ELF64Header {
    <span class="kw">pub </span>e_ident: [u8; <span class="number">16</span>],
    <span class="kw">pub </span>e_type: u16,
    <span class="kw">pub </span>e_machine: u16,
    <span class="kw">pub </span>e_version: u32,
    <span class="kw">pub </span>e_entry: u64,
    <span class="kw">pub </span>e_phoff: u64,
    <span class="kw">pub </span>e_shoff: u64,
    <span class="kw">pub </span>e_flags: u32,
    <span class="kw">pub </span>e_ehsize: u16,
    <span class="kw">pub </span>e_phentsize: u16,
    <span class="kw">pub </span>e_phnum: u16,
    <span class="kw">pub </span>e_shentsize: u16,
    <span class="kw">pub </span>e_shnum: u16,
    <span class="kw">pub </span>e_shstrndx: u16,
}

<span class="comment">// SAFE: ELF64Header satisfies all the requirements of `Plain`.
</span><span class="kw">unsafe impl </span>Plain <span class="kw">for </span>ELF64Header {}

<span class="kw">impl </span>ELF64Header {
	<span class="kw">fn </span>from_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="kw-2">&amp;</span>ELF64Header {
		plain::from_bytes(buf).expect(<span class="string">&quot;The buffer is either too short or not aligned!&quot;</span>)
	}

	<span class="kw">fn </span>from_mut_bytes(buf: <span class="kw-2">&amp;mut </span>[u8]) -&gt; <span class="kw-2">&amp;mut </span>ELF64Header {
		plain::from_mut_bytes(buf).expect(<span class="string">&quot;The buffer is either too short or not aligned!&quot;</span>)
	}

	<span class="kw">fn </span>copy_from_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; ELF64Header {
		<span class="kw">let </span><span class="kw-2">mut </span>h = ELF64Header::default();
		h.copy_from_bytes(buf).expect(<span class="string">&quot;The buffer is too short!&quot;</span>);
		h
	}
}


<span class="comment">// Conditional copying for ultimate hackery.
</span><span class="kw">fn </span>opportunistic_elf_processing(buf: <span class="kw-2">&amp;</span>[u8]) {
	<span class="kw">if </span>plain::is_aligned::&lt;ELF64Header&gt;(buf) {
        <span class="comment">// No copy necessary.
		</span><span class="kw">let </span>elf_ref = ELF64Header::from_bytes(buf);
		process_elf(elf_ref);
    } <span class="kw">else </span>{
        <span class="comment">// Not aligned properly, copy to stack first.
		</span><span class="kw">let </span>elf = ELF64Header::copy_from_bytes(buf);
		process_elf(<span class="kw-2">&amp;</span>elf);
    }
}

<span class="attr">#[repr(C)]
#[derive(Default, Copy, Clone)]
</span><span class="kw">struct </span>ArrayEntry {
    <span class="kw">pub </span>name: [u8; <span class="number">32</span>],
    <span class="kw">pub </span>tag: u32,
    <span class="kw">pub </span>score: u32,
}

<span class="comment">// SAFE: ArrayEntry satisfies all the requirements of `Plain`.
</span><span class="kw">unsafe impl </span>Plain <span class="kw">for </span>ArrayEntry {}

<span class="kw">fn </span>array_from_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="kw-2">&amp;</span>[ArrayEntry] {
    <span class="comment">// NOTE: length is not a concern here,
    // since slice_from_bytes() can return empty slice.

    </span><span class="kw">match </span>plain::slice_from_bytes(buf) {
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;The buffer is not aligned!&quot;</span>),
        <span class="prelude-val">Ok</span>(arr) =&gt; arr,
    }
}

<span class="kw">fn </span>array_from_unaligned_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; Vec&lt;ArrayEntry&gt; {
	<span class="kw">let </span>length = buf.len() / mem::size_of::&lt;ArrayEntry&gt;();
	<span class="kw">let </span><span class="kw-2">mut </span>result = <span class="macro">vec!</span>[ArrayEntry::default(); length];
 	(<span class="kw-2">&amp;mut </span>result).copy_from_bytes(buf).expect(<span class="string">&quot;Cannot fail here.&quot;</span>);
	result
}

</code></pre></div>
<h2 id="comparison-to-pod"><a href="#comparison-to-pod">Comparison to <code>pod</code></a></h2>
<p><a href="https://crates.io/crates/pod"><code>pod</code></a> is another crate created to help working with plain data.
The major difference between <code>pod</code> and <code>plain</code> is scope.</p>
<p><code>plain</code> currently provides only a few functions (+method wrappers) and its implementation
involves very few lines of unsafe code. It can be used in <code>no_std</code> code. Also, it doesn’t
deal with <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> in any way,
so it is only suitable for certain kinds of low-level work.</p>
<p><code>pod</code>, on the other hand, provides a wide arsenal
of various methods, most of which may be unnecessary for a given use case.
It has dependencies on <code>std</code> as well as other crates, but among other things
it provides tools to handle endianness properly.</p>
<p>In short, <code>plain</code> is much, much <em>plainer</em>…</p>
</div></details><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum plain::Error">Error</a></div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Plain.html" title="trait plain::Plain">Plain</a></div><div class="desc docblock-short">A trait for plain data types that can be safely read from a byte slice.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.as_bytes.html" title="fn plain::as_bytes">as_bytes</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Interpret data as bytes. Not safe for data with padding.</div></li><li><div class="item-name"><a class="fn" href="fn.as_mut_bytes.html" title="fn plain::as_mut_bytes">as_mut_bytes</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Interpret data as mutable bytes.
Reading is not safe for data with padding. Writing is ok.</div></li><li><div class="item-name"><a class="fn" href="fn.copy_from_bytes.html" title="fn plain::copy_from_bytes">copy_from_bytes</a></div><div class="desc docblock-short">Copies data from a byte slice into existing memory.
Suitable when <a href="fn.from_bytes.html"><code>from_bytes()</code></a> would normally
be used, but the data is not aligned properly in memory.</div></li><li><div class="item-name"><a class="fn" href="fn.from_bytes.html" title="fn plain::from_bytes">from_bytes</a></div><div class="desc docblock-short">Safely converts a byte slice to a reference.</div></li><li><div class="item-name"><a class="fn" href="fn.from_mut_bytes.html" title="fn plain::from_mut_bytes">from_mut_bytes</a></div><div class="desc docblock-short">See <a href="fn.from_bytes.html"><code>from_bytes()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.is_aligned.html" title="fn plain::is_aligned">is_aligned</a></div><div class="desc docblock-short">Check if a byte slice is aligned suitably for type T.</div></li><li><div class="item-name"><a class="fn" href="fn.slice_from_bytes.html" title="fn plain::slice_from_bytes">slice_from_bytes</a></div><div class="desc docblock-short">Similar to <a href="fn.from_bytes.html"><code>from_bytes()</code></a>,
except that the output is a slice of T, instead
of a reference to a single T. All concerns about
alignment also apply here, but size is handled
differently.</div></li><li><div class="item-name"><a class="fn" href="fn.slice_from_bytes_len.html" title="fn plain::slice_from_bytes_len">slice_from_bytes_len</a></div><div class="desc docblock-short">Same as <a href="fn.slice_from_bytes.html"><code>slice_from_bytes()</code></a>,
except that it takes explicit length of the result slice.</div></li><li><div class="item-name"><a class="fn" href="fn.slice_from_mut_bytes.html" title="fn plain::slice_from_mut_bytes">slice_from_mut_bytes</a></div><div class="desc docblock-short">See <a href="fn.slice_from_bytes.html"><code>slice_from_bytes()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.slice_from_mut_bytes_len.html" title="fn plain::slice_from_mut_bytes_len">slice_from_mut_bytes_len</a></div><div class="desc docblock-short">See <a href="fn.slice_from_bytes_len.html"><code>slice_from_bytes_len()</code></a>.</div></li></ul></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="plain" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (f63ccaf25 2023-03-06)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>