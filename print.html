<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cryptatools-rs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="philosophy.html"><strong aria-hidden="true">1.</strong> Philosophy</a></li><li class="chapter-item expanded "><a href="licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="contact.html"><strong aria-hidden="true">3.</strong> Contacts</a></li><li class="chapter-item expanded affix "><li class="part-title">I - Tutorials</li><li class="chapter-item expanded "><a href="chapter_1/1-get-started.html"><strong aria-hidden="true">4.</strong> Get Started</a></li><li class="chapter-item expanded "><a href="chapter_1/2-installation.html"><strong aria-hidden="true">5.</strong> Installation</a></li><li class="chapter-item expanded "><a href="chapter_1/3-contribute.html"><strong aria-hidden="true">6.</strong> Contribute</a></li><li class="chapter-item expanded "><a href="chapter_1/4-usage.html"><strong aria-hidden="true">7.</strong> Usage</a></li><li class="chapter-item expanded affix "><li class="part-title">II - How To</li><li class="chapter-item expanded affix "><li class="part-title">1. Cryptanalysis for Reverse engineering and malware analysis</li><li class="chapter-item expanded "><a href="chapter_2/1-caesar_shellcode_cryptanalysis_attack.html"><strong aria-hidden="true">8.</strong> Using Cryptanalysis Attack Method Against A Caesar Encryption Shellcode Shellcode For Malware Analysis With Cryptatools And Radare2 Rust Bindings (r2pipe)</a></li><li class="chapter-item expanded affix "><li class="part-title">2. Blockchain and cryptocurrencies cryptanalysis</li><li class="chapter-item expanded "><a href="chapter_2/Blockchain/1-Evaluating-bitcoin-wallet-collision-probability.html"><strong aria-hidden="true">9.</strong> Cryptography Of Bitcoin Address Using Birthday Paradox</a></li><li class="chapter-item expanded affix "><li class="part-title">III - API Ref</li><li class="chapter-item expanded "><a href="chapter_3/api-ref.html"><strong aria-hidden="true">10.</strong> API-Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">IV - Explanations</li><li class="chapter-item expanded "><a href="chapter_4/1-goals-of-cryptanalysis.html"><strong aria-hidden="true">11.</strong> Why doing Cryptanalysis</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cryptatools-rs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cryptatools-rs-philosophy"><a class="header" href="#cryptatools-rs-philosophy">Cryptatools-rs Philosophy</a></h1>
<p><code>cryptatools-rs</code> is a cryptanalysis tool against custom or wrongly implemented algorithm.</p>
<p>This tool aims to be professionnal. Not only a learning tool. It is for realistic exploitation and code breaking.</p>
<p>You can &quot;plug-in&quot; your script to any protocol. Man in the midle as well as blockchain core as well as anything. Example:</p>
<ul>
<li>You are able to use <code>pypcap</code> python library to read packets and then <code>dpkt</code> python library to parse these and then you can use <code>cryptatools</code> to break encryption on these packets. This is why this library is avaible in many bindings such as python.</li>
<li>You are able to use <code>rust-web3</code> to parse a vulnerable cryptocurrency (shitcoin) blockchain hash tree to steal money using collision attack to forge a signature. See <a href="https://github.com/mit-dci/tangled-curl/blob/master/vuln-iota.md#steal-money-attack">this reference</a>.</li>
</ul>
<p>You can also work on programs obfuscated by encryption such as malware. In this case, you can decipher program data (eg: data contained in a dropper) as well as self-encrypyted code. In this way you can plug cryptatools with your favorite reverse engineering framwork. Eg:</p>
<ul>
<li>Install radare2. Then do <code>radare2 -AA -i &lt;yourscriptname&gt;.rs &lt;yourmalwaretoreverse&gt;</code>. If you work with python bindings, <code>radare2 -AA -i &lt;yourscriptname&gt;.py &lt;yourmalwaretoreverse&gt;</code></li>
<li>You can also work on extracted code from the malware:</li>
</ul>
<pre><code class="language-shell">radare2 &lt;malwaretoreverse&gt;; 
=&gt; s sym.encrypted;
pr 12345 &gt; ciphertext.bin
</code></pre>
<p>Where 12345 is the size of the encrypted function or code of the malware.</p>
<p>The library is very very flexible. One of the main concept is to break custom cryptography. That is why you can meet classic cryptanalysis in <code>cryptatools</code>. This flexibility also aim to break obfuscation/encrypted malware. These are often written in assembly language because they deal with the system and then need to reimplement a lot of things and so their encryption method are often poorly written.</p>
<p>You can automatize any task. There is a command line interface.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="licence"><a class="header" href="#licence">Licence</a></h2>
<p>This software has a free software (libre) license. The license is GPL3. </p>
<p>Fell free to ask me if you absolutely want to get a double licensing name. Then I could choose.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contact"><a class="header" href="#contact">Contact</a></h1>
<ul>
<li>Join: <a href="https://discord.gg/YmtCsghFgu">our discord server</a></li>
<li>Project Link: <a href="https://github.com/gogo2464/cryptatools-rs">https://github.com/gogo2464/cryptatools-rs</a></li>
<li>gogo - gogo246475@gmail.com</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>This is a cryptanalysis tool against custom or wrongly implemented algorithm for cybersecurity researcher, exploit developers and ctf players.</p>
<p>The name come from pwntools a similar tool to exploit memory corruption vulnerabilities. This software aims to work like pwntools but for cryptanalysis.</p>
<p>Then this program include a library like pwnlib. And it will expose some command line tools. Like pwntools. This is a rewrite of the python version in rust in order to be able to be fast and portable and usable in the following various languages rust, python, ruby, javascript and kotlin together.</p>
<p>Full documentation is avaible at <a href="https://gogo2464.github.io/cryptatools-rs/">this address</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<h3 id="1-rust-library-installation"><a class="header" href="#1-rust-library-installation">1-Rust library installation.</a></h3>
<p>Installation of <code>cryptatools-core</code> for rust is same for any OS. In <code>Cargo.toml</code>, just write:</p>
<pre><code class="language-shell">[dependencies]
cryptatools-core = { git = &quot;https://github.com/gogo2464/cryptatools-rs&quot;, package = 'cryptatools-core' }
</code></pre>
<p>Works on rust stable, unstable as well as nightly toolchains.</p>
<h3 id="2-python-binding-installation"><a class="header" href="#2-python-binding-installation">2-Python binding installation.</a></h3>
<p>To install the python Bindings you can use pip or build from source:</p>
<h3 id="21-install-python-bindings-from-pip"><a class="header" href="#21-install-python-bindings-from-pip">2.1-Install python Bindings from pip:</a></h3>
<p>The name <code>cryptatools-python3</code> is the name of the package used to install cryptatools core python bindings. In order to install it, do:</p>
<pre><code>pip install cryptatools-python3
</code></pre>
<p>It is updated of 1 subversion on each Pull Request and is then often update by the previous version.</p>
<h3 id="22-build-python-bindings-from-sources"><a class="header" href="#22-build-python-bindings-from-sources">2.2-Build Python Bindings from sources</a></h3>
<p>If you are on windows, with powershell do:</p>
<pre><code class="language-powershell">python -m venv myenv
.\myenv\Script\activate
pip install setuptools wheel
git clone https://github.com/gogo2464/cryptatools-rs ;
cd cryptatools-rs
python .\cryptatools-core\setup.py bdist_wheel --verbose ;
$wheelFile = Get-ChildItem -Path .\dist\ -Recurse -Include * ;
pip3 install $wheelFile --force-reinstall ;
</code></pre>
<p>If you are on Linux, do:</p>
<pre><code class="language-shell">virtualenv -p python3 myenv
source myenv/bin/activate
pip install setuptools wheel
git clone https://github.com/gogo2464/cryptatools-rs ;
cd cryptatools-rs
python3 ./cryptatools-core/setup.py bdist_wheel --verbose ;
pip3 install ./dist/* --force-reinstall ;
</code></pre>
<p>If you are on MacOs, do:</p>
<pre><code class="language-shell">virtualenv -p python3 myenv
source myenv/bin/activate
pip install setuptools wheel
git clone https://github.com/gogo2464/cryptatools-rs ;
cd cryptatools-rs
python3 ./cryptatools-core/setup.py bdist_wheel --verbose ;
pip3 install ./dist/* --force-reinstall ;
</code></pre>
<h3 id="3-cryptatools-cli-the-cli-intreface"><a class="header" href="#3-cryptatools-cli-the-cli-intreface">3-cryptatools-cli the cli intreface</a></h3>
<p>Crytptatools command line interface is split into various program in order to follow the Linux philosophy. To install each one, do:</p>
<pre><code class="language-shell">git clone https://github.com/gogo2464/cryptatools-rs/ &amp;&amp;
cargo install --path .\cryptatools-rs\cryptatools-cli\ ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are <strong>greatly appreciated</strong>.</p>
<p>If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag &quot;enhancement&quot;.
Don't forget to give the project a star! Thanks again!</p>
<ol>
<li>Document your work. See <a href="https://github.com/gogo2464/cryptatools-rs#1-documentation">the how to make good documentation</a> chapter.</li>
<li>For each method or object implemented, do not forget to make tests with doctest. See <a href="https://github.com/gogo2464/cryptatools-rs#2-testing">here</a>.</li>
<li>Create Python binding. See <a href="https://github.com/gogo2464/cryptatools-rs#3-create-python-bindings">this link</a>.</li>
<li>Benchmark your work. See <a href="https://github.com/gogo2464/cryptatools-rs#4-benchmarking">this link</a>.</li>
<li>Create cli interface. See <a href="https://github.com/gogo2464/cryptatools-rs#5-create-cli">This link</a>.</li>
<li>Open PR.</li>
</ol>
<h2 id="1-documentation"><a class="header" href="#1-documentation">1-Documentation</a></h2>
<p>The documentation is generated by doctstring with rustdoc. To edit the documentation, go to the code and modify the doctstring after <code>///</code>.</p>
<p>Then, in order to generate documentation from root folder do:</p>
<pre><code class="language-shell">cargo doc --all --no-deps
</code></pre>
<p>Fell free to view your own doc with</p>
<pre><code>cargo doc --open --all --no-deps
</code></pre>
<p>This project uses <code>cargo doc</code>.</p>
<p>The documentation is self-generated on each pull request.</p>
<p>To check if the cryptatools documentation has been updated after a merge request, see: <a href="https://gogo2464.github.io/cryptatools-rs/cryptatools_core/">the API documentation</a>.</p>
<h2 id="2-testing"><a class="header" href="#2-testing">2-Testing</a></h2>
<p>In order to run unit tests, you MUST be in the directory cryptatools-rs.
Run unit tests with doctests with the command:</p>
<pre><code class="language-shell">cargo test --all
</code></pre>
<p>Unit test are made with doctests.</p>
<p align="right">(<a href="chapter_1/3-contribute.html#top">back to top</a>)</p>
<h2 id="3-create-python-bindings"><a class="header" href="#3-create-python-bindings">3-Create Python bindings.</a></h2>
<p>Cryptatools relies on uniffi to provide bindings to Python3. Ensure to provide Python3 bindings before making your Pull Request.</p>
<p>To create Python Bindings, edit the file <code>cryptatools-rs/src/cryptatools.udl</code>. Edit it to add your newly created object as mentionned in the official uniffi documentation at this address: https://mozilla.github.io/uniffi-rs/udl_file_spec.html.</p>
<p>Then do not forget to edit the file <code>cryptatools-rs/cryptatools-core/src/lib.rs</code> and just before the:</p>
<pre><code>uniffi_macros::include_scaffolding!(&quot;cryptatools&quot;);
</code></pre>
<p>This step will generate a single python file that you could import directly. Sadly the good pratice you must do to import these is a bit more complicated.</p>
<p><code>cryptatools-rs\cryptatools-core\setup.py</code></p>
<p>In order to import your own crate, create the corresponding python file or folders under <code>cryptatools-rs\cryptatools-core\bindings\python3\cryptatools-core\cryptanalysis\</code>. Here you need to import the necessary objects from from <code>cryptatools_core.python3_bindings</code>. Example, in the file <code>cryptatools-rs\cryptatools-core\bindings\python3\cryptatools-core\cryptography\encryption\monoalphabetic_cipher\caesar_number.py</code> we just have written: <code>from cryptatools_core.python3_bindings import CaesarNumberAlgorithm</code>.</p>
<p>Once this is done, fell free to write unit tests. At least one for each method implemented. The tests are writtenh in the file <code>cryptatools-rs\cryptatools-core\binding-testing\testing.py</code>.</p>
<p>You are now free to test and compile your code with <a href="https://github.com/gogo2464/cryptatools-rs#2-python-binding-installation">the documentation at this link</a>.</p>
<h2 id="4-benchmarking"><a class="header" href="#4-benchmarking">4-Benchmarking</a></h2>
<p>Sometimes, a function could sepnd too much time. In this case, you can debug your specific function from the template in the file <code>benches\cryptatools_benchmark\main.rs</code>.</p>
<p>Then test your function with:</p>
<pre><code class="language-shell">cargo bench
</code></pre>
<p>In the current state of cryptatools, it is not mandatory from a pull request to benchmark all the code. But could be considered as a good improvment.</p>
<h2 id="5-create-cli"><a class="header" href="#5-create-cli">5-Create cli.</a></h2>
<p>Each feature from cryptatools-core will be implemented to the cli in the folder <code>cryptatools-cli</code>. When you will have finish to implement your feature in incryptatools-core and when you have finish your feature in Python bindings, fell free to create the cli of your modifications.</p>
<p>Then test it with:</p>
<pre><code class="language-shell">cargo install --path .\cryptatools-cli\ ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>crypytatools-cli also offers a way to script the library in command line. Do not forget to install each program. See how to install these <a href="https://github.com/gogo2464/cryptatools#installation">here</a> for more informations.</p>
<p><code>cryptatools-cli-stats</code> does cryptanalysis statistical attacks. It takes as first argument the statistical attack algorithm (example coincidence index, frequency analysis, etc...), as second argument the source encrypted opcodes to make attack on, at last but not least, it takes a json value of the corresponding alphabet corresponding to each set of opcodes.</p>
<p>On windows:</p>
<pre><code class="language-powershell">cryptatools-cli-stats frequency-analysis &quot;123234&quot; '{\&quot;a\&quot;: [\&quot;12\&quot;], \&quot;b\&quot;: [\&quot;32\&quot;], \&quot;c\&quot;: [\&quot;34\&quot;]}'
</code></pre>
<p>On Linux:</p>
<pre><code>cryptatools-cli-stats frequency-analysis &quot;123234&quot; '{&quot;a&quot;: [&quot;12&quot;], &quot;b&quot;: [&quot;32&quot;], &quot;c&quot;: [&quot;34&quot;]}'
</code></pre>
<p><code>cryptatools-cli-encrypt</code> uses cryptography algorithm to encrypt data. Obviously you can use it for brute force cryptanalysis attack. But it is not the main philosophy of <code>cryptatools-rs</code>.</p>
<pre><code class="language-shell"></code></pre>
<p>For more examples, please refer to the <a href="https://github.com/gogo2464/cryptatools-rs/blob/master/TUTORIAL.md">Tutorial</a> or to the documentation <a href="https://gogo2464.github.io/cryptatools-rs/cryptatools_core/">Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-cryptanalysis-attack-method-against-a-caesar-encryption-shellcode-shellcode-for-malware-analysis-with-cryptatools-and-radare2-rust-bindings-r2pipe"><a class="header" href="#use-cryptanalysis-attack-method-against-a-caesar-encryption-shellcode-shellcode-for-malware-analysis-with-cryptatools-and-radare2-rust-bindings-r2pipe">Use cryptanalysis attack method against a caesar encryption shellcode shellcode for Malware analysis with cryptatools and radare2 rust bindings (r2pipe)</a></h2>
<h3 id="1-introduction"><a class="header" href="#1-introduction">1-Introduction</a></h3>
<p>Knowledge required:</p>
<ul>
<li>cryptanalysis on caesar cipher</li>
<li><a href="https://pacman128.github.io/pcasm/">x86_32 assembly language programming. Check your language here.</a></li>
</ul>
<p>Shellstorm is a pentester ressource. They provide shellcode for cyber security researcher. Sadly their shellcode could be used by hackers in order to create computer trojan. Hackers could include the shellcode in an image or an executable to add trojan during the execution of the file.</p>
<p>One of these shellcode uses caesar to obfuscate his signature against anti-virus.</p>
<p>Today we are going to use cryptatools to break the caesar encryption algorithm to deobfuscate a malware for reverse engineering purpose. We will explore the different way than brute force to break this caesar encryption and we will break ceasar at least.</p>
<h3 id="2-reverse-engineering-the-shellcode"><a class="header" href="#2-reverse-engineering-the-shellcode">2-Reverse Engineering the shellcode</a></h3>
<p>We want to see the machine code of the shellcode in order to see were the data is stocked and to do reverse engineering in order to ensure the encryption algorithm.</p>
<p>In the case of this analysis, we have access to the <a href="http://shell-storm.org/shellcode/files/shellcode-900.html">Shellstorm shellcode sample link here</a>. So we already have the opcode of the shellcode in the format <code>\x12\x34</code>. So let's copy the opcodes <code>\xeb\x25\x5e\x31\xc9\xb1\x1e\x80\x3e\x07\x7c\x05\x80\x2e\x07\xeb\x11\x31\xdb\x31\xd2\xb3\x07\xb2\xff\x66\x42\x2a\x1e\x66\x29\xda\x88\x16\x46\xe2\xe2\xeb\x05\xe8\xd6\xff\xff\xff\x38\xc7\x57\x6f\x69\x68\x7a\x6f\x6f\x69\x70\x75\x36\x6f\x36\x36\x36\x36\x90\xea\x57\x90\xe9\x5a\x90\xe8\xb7\x12\xd4\x87</code> to the file <code>shellcode.txt</code>.</p>
<p>Then we are now going to compile the shellcode in order to disassemble it.</p>
<p>First parse it to get an opcode format such as format <code>1234</code>:</p>
<pre><code class="language-shell">echo &quot;$(cat shellcode.txt | tr -d 'x' | tr -d '\\' | tr -d '\n')&quot; &gt; opcode.txt
</code></pre>
<p>Then let's compile it really:</p>
<pre><code class="language-shell">xxd -r -p opcode.txt bin
</code></pre>
<p>The file bin is created. It is the assembled shellcode. We could as well run it with:</p>
<pre><code class="language-shell">chmod u+x ./bin
./bin
</code></pre>
<p>But our goal is to break it. Not to let it infect us. So let's disassemble it with radare2:</p>
<pre><code class="language-shell">radare2 -a x86 -b 32 ./bin
</code></pre>
<p>radare2 is a reverse engineering framwork. We could use it to read the shellcode machine code. The option <code>-a x86</code> tells radare2 to disassemble an x86 processor machine code. The option <code>-b 32</code> tells radare2 to read 32 bit code. We could use <code>-AA</code> to provide as much information as possible about the binary. We prefer manual documentation in this tutorial.</p>
<p>Now in the radare2 console, type <code>Vp</code> to switch to the disassembled machine code, then you can read the code of the shellcode.</p>
<pre><code class="language-assembly">jmp 0x27
pop esi
xor ecx, ecx
mov cl, 0x1e
cmp byte [esi], 7
jl 0x11
sub byte [esi], 7
jmp 0x22
xor ebx, ebx
xor edx, edx
mov bl, 7
mov dl, 0xff
inc dx
sub bl, byte [esi]
sub dx, bx
mov byte [esi], dl
inc esi
loop 7
jmp 0x2c
call 0x02
cmp bh, al
push edi
outsd dx, dword [esi]
imul ebp, dword [eax + 0x7a], 0x70696f6f
jne 0x6f
outsd dx, dword [esi]
nop
ljmp 0xe890
mov bh, 0x12
aam 0x87
</code></pre>
<p>Let's add some labels to document it:</p>
<pre><code class="language-assembly">_start:
    jmp call_decoder
decoder:
    pop esi
    xor ecx, ecx
    mov cl, 0x1e
decode:
    cmp byte [esi], 7
    jl lowbound
    sub byte [esi], 7
    jmp 0x22
lowbound:
    xor ebx, ebx
    xor edx, edx
    mov bl, 7
    mov dl, 0xff
    inc dx
    sub bl, byte [esi]
    sub dx, bx
    mov byte [esi], dl
common_command:
    inc esi
    loop 7
    jmp shellcode
call_decoder:
    call decoder
shellcode:
    cmp bh, al
    push edi
    outsd dx, dword [esi]
    imul ebp, dword [eax + 0x7a], 0x70696f6f
    jne 0x6f
    outsd dx, dword [esi]
    nop
    ljmp 0xe890
    mov bh, 0x12
    aam 0x87
</code></pre>
<p>Let's read the assembly code of the shellcode!</p>
<p>The instruction <code>jmp call_decoder</code> go to the label call_decoder. Then the instruction <code>call decoder</code> is called. In order to really understsand the shellcode we have to dig deeply on what the instruction <code>call decoder</code> does. Even if you know assembly language, do not miss this step.</p>
<p>In x86 assembly language, the instruction call does not only jump to the label. It pushes the next instruction address to the stack and then, when the instruction left, uses a <code>pop eip</code> instruction to come back to the next instruction.</p>
<p>In shellcoding, it is a very intresting feature because, in this shellcode, the address of the label <code>shellcode</code> is pushed to the stack.</p>
<pre><code class="language-assembly">decoder:
    pop esi
</code></pre>
<p>As first instruction of the called function we could see a very tricky and interesting property of the assembly language. The shellcode address is poped on the esi!!!</p>
<p><code>cl</code> is the register that stores the size of the encrypted content. It is then <code>0x1e</code>.</p>
<p>Let's read the encrypted content:</p>
<pre><code class="language-shell">p8 0x1e @ 0x2c ;
38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487
</code></pre>
<p><code>38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487</code> is the cipher text. </p>
<p>Now that we know where the shellcode is (at the label shellcode), we will break it using in a first time only cryptatools cryptanalysis method. Then we will explore each way to solve the problem. We will start by the most cryptanalystic method and finish with the less cryptanalystic method.</p>
<h3 id="31-caesar-statistical-analysis-try-when-the-shellcode-size-is-too-little"><a class="header" href="#31-caesar-statistical-analysis-try-when-the-shellcode-size-is-too-little">3.1 Caesar statistical analysis: Try when the shellcode size is too little.</a></h3>
<p>The global idea is to see at which frequency each opcode appears in the code and then compare with the frequency distribution of plain text opcodes in a shellcode database or a malware database as well as a goodware database (trough less accurate).</p>
<p>According to the work of <code>Babak Bashari Rad</code>, we already have the statistical distribution for main opcodes in x86:</p>
<p><a href="https://www.researchgate.net/profile/Babak-Bashari-Rad/publication/235641144/figure/tbl2/AS:669345520828438@1536595816633/Opcodes-Statistics-for-each-class-of-our-data-set.png"><img src="https://www.researchgate.net/profile/Babak-Bashari-Rad/publication/235641144/figure/tbl2/AS:669345520828438@1536595816633/Opcodes-Statistics-for-each-class-of-our-data-set.png" alt="image to statistics" /></a></p>
<p><a href="https://www.researchgate.net/figure/Opcodes-Statistics-for-each-class-of-our-data-set_tbl2_235641144">See his work here</a>.</p>
<p>So let's calculate frequency distribution in order to compare the plain with the cipher text and see similarities.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;caesar_shellcode_1_statistical_analysis&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
cryptatools-core = { git = &quot;https://github.com/gogo2464/cryptatools-rs&quot;, package = 'cryptatools-core' }
serde_json = &quot;1.0.91&quot;
r2pipe = { git = &quot;https://github.com/RHL120/r2pipe.rs&quot;, branch = &quot;windows_bad&quot; }
itertools = &quot;0.10.5&quot;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use r2pipe::R2Pipe;
use r2pipe::open_pipe;
use cryptatools_core::utils::alphabets::Alphabet;
use cryptatools_core::cryptanalysis::general_cryptanalysis_methods::frequency_analysis::distribution_algorithms::statistical::Statistical;
use std::u8;

fn read_plain_text(cipher_text: String) -&gt; Vec&lt;u8&gt; {
  let mut bytes = Vec::new();
  for o in (0..cipher_text.len()).step_by(2) {
	let left = cipher_text.chars().nth(o).unwrap();
	let right = cipher_text.chars().nth(o+1).unwrap();
	let mut opcode = String::from(left);
	opcode.push(right);
	bytes.push(u8::from_str_radix(&amp;opcode, 16).unwrap());
  }	
  
  bytes
}

fn main() {
  let mut r2p = open_pipe!(Some(&quot;bin&quot;)).unwrap();
  let mut cipher_text = String::from(r2p.cmd(&quot;p8 0x1e @ 0x2c ;&quot;).unwrap());
  cipher_text.remove(cipher_text.len()-1);
  cipher_text.remove(cipher_text.len()-1);
  
  println!(&quot;cipher text: {:?}&quot;, cipher_text);
  
  let unknow_opcode_alphabet = Alphabet::new_empty().unknow_opcodes();
  
  let bytes = read_plain_text(cipher_text);
  
  let stat = Statistical::new(unknow_opcode_alphabet.clone());
  let stat_percentage = stat.guess_statistical_distribution(bytes);
  
  for character in stat_percentage {
	  for opcode in character.0 {
		  println!(&quot;opcode {:x}, statistic: {:?}&quot;, opcode, character.1);
	  }
	  
  }
  
  r2p.close();
}</code></pre></pre>
<p>Let's run it with:</p>
<pre><code class="language-powershell">cargo run
   Compiling caesar_shellcode_1_statistical_analysis v0.1.0 (C:\Users\TRUNCATED\Desktop\cryptatools-rs\tutos\caesar_shellcode_1_statistical_analysis)
    Finished dev [unoptimized + debuginfo] target(s) in 1.15s
     Running `target\debug\caesar_shellcode_1_statistical_analysis.exe`
cipher text: &quot;38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487&quot;
opcode e9, statistic: 0.03333333333333333
opcode e8, statistic: 0.03333333333333333
opcode 5a, statistic: 0.03333333333333333
opcode b7, statistic: 0.03333333333333333
opcode 36, statistic: 0.16666666666666666
opcode ea, statistic: 0.03333333333333333
opcode 57, statistic: 0.06666666666666667
opcode 6f, statistic: 0.13333333333333333
opcode 69, statistic: 0.06666666666666667
opcode 87, statistic: 0.03333333333333333
opcode 38, statistic: 0.03333333333333333
opcode 12, statistic: 0.03333333333333333
opcode c7, statistic: 0.03333333333333333
opcode 68, statistic: 0.03333333333333333
opcode 75, statistic: 0.03333333333333333
opcode 70, statistic: 0.03333333333333333
opcode 90, statistic: 0.1
opcode 7a, statistic: 0.03333333333333333
opcode d4, statistic: 0.03333333333333333
</code></pre>
<p>The most frequent opcodes are: <code>36</code>, <code>6f</code> and <code>90</code>.</p>
<p>These could be either: <code>mov</code>, <code>push</code> or <code>call</code>.</p>
<h3 id="3111-is-36-a-mov-89"><a class="header" href="#3111-is-36-a-mov-89">3.1.1.1 Is 36 a mov (89)?</a></h3>
<p>Let's manually try to replace <code>36</code> by <code>mov</code> and see:</p>
<pre><code class="language-powershell">rasm2 -a x86 -b 32 &quot;mov eax, eax&quot;
89c0
</code></pre>
<p>so let's replace <code>36</code> by <code>89</code>.</p>
<pre><code class="language-powershell">$text = &quot;38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487&quot; ; $text = $text -replace &quot;36&quot;,&quot;89&quot;
rasm2 -a x86 -b 32 -D $text

0x00000000   2                     38c7  cmp bh, al
0x00000002   1                       57  push edi
0x00000003   1                       6f  outsd dx, dword [esi]
0x00000004   7           69687a6f6f6970  imul ebp, dword [eax + 0x7a], 0x70696f6f
0x0000000b   2                     7589  jne 0xffffff96
0x0000000d   1                       6f  outsd dx, dword [esi]
0x0000000e   6             8989898990ea  mov dword [ecx - 0x156f7677], ecx
0x00000014   1                       57  push edi
0x00000015   1                       90  nop
0x00000016   5               e95a90e8b7  jmp 0xb7e89075
0x0000001b   2                     12d4  adc dl, ah
0x0000001d   1                       87  invalid
</code></pre>
<p>We have an invalid opcode. We can only be wrong.</p>
<h3 id="3112-is-36-a-push-50-"><a class="header" href="#3112-is-36-a-push-50-">3.1.1.2 Is 36 a push (50) ?</a></h3>
<p>Let's manually try to replace <code>36</code> by <code>push</code> and see:</p>
<pre><code class="language-powershell">rasm2 -a x86 -b 32 &quot;push eax&quot;
50
</code></pre>
<p>As I guess there could be many opcode for <code>push</code> dependig of the second operand. We will use guess it is a call of we do not find better before.</p>
<h3 id="3113-is-36-a-call-e8"><a class="header" href="#3113-is-36-a-call-e8">3.1.1.3 Is 36 a call (e8)?</a></h3>
<pre><code class="language-powershell">rasm2 -a x86 -b 32 &quot;call 0x00&quot;
e8fbffffff
</code></pre>
<pre><code class="language-powershell">$text = &quot;38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487&quot; ; $text = $text -replace &quot;36&quot;,&quot;89&quot;
rasm2 -a x86 -b 32 -D $text
0x00000000   2                     38c7  cmp bh, al
0x00000002   1                       57  push edi
0x00000003   1                       6f  outsd dx, dword [esi]
0x00000004   7           69687a6f6f6970  imul ebp, dword [eax + 0x7a], 0x70696f6f
0x0000000b   2                     7589  jne 0xffffff96
0x0000000d   1                       6f  outsd dx, dword [esi]
0x0000000e   6             8989898990ea  mov dword [ecx - 0x156f7677], ecx
0x00000014   1                       57  push edi
0x00000015   1                       90  nop
0x00000016   5               e95a90e8b7  jmp 0xb7e89075
0x0000001b   2                     12d4  adc dl, ah
0x0000001d   1                       87  invalid
</code></pre>
<p>Invalid. It is a fail!</p>
<h3 id="3114-is-36-another-push-"><a class="header" href="#3114-is-36-another-push-">3.1.1.4 Is 36 another push ?</a></h3>
<p>Now we have eliminated any other possibility, we know that <code>36</code> is probably register or stack data. let's see latter.</p>
<h3 id="3121-is-6f-a-mov-push-or-a-call-lets-try-a-mov"><a class="header" href="#3121-is-6f-a-mov-push-or-a-call-lets-try-a-mov">3.1.2.1 is <code>6f</code> a <code>mov</code>, <code>push</code> or a <code>call</code>. Let's try a <code>mov</code></a></h3>
<pre><code class="language-powershell">rasm2 -a x86 -b 32 &quot;mov eax, eax&quot;
89c0
</code></pre>
<pre><code class="language-powershell">$text = &quot;38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487&quot; ; $text = $text -replace &quot;6f&quot;,&quot;89&quot;
rasm2 -a x86 -b 32 -D $text
0x00000000   2                     38c7  cmp bh, al
0x00000002   1                       57  push edi
0x00000003   3                   896968  mov dword [ecx + 0x68], ebp
0x00000006   2                     7a89  jp 0xffffff91
0x00000008   3                   896970  mov dword [ecx + 0x70], ebp
0x0000000b   2                     7536  jne 0x43
0x0000000d   2                     8936  mov dword [esi], esi
0x0000000f   4                 36363690  nop
0x00000013   7           ea5790e95a90e8  ljmp 0xe890:0x5ae99057
0x0000001a   2                     b712  mov bh, 0x12
0x0000001c   2                     d487  aam 0x87
</code></pre>
<p>Seems to be possible. But the <code>jp</code> instruction is weird. Let's continue to see.</p>
<h3 id="3122-is-6f-a-mov-push-or-a-call-lets-try-a-push"><a class="header" href="#3122-is-6f-a-mov-push-or-a-call-lets-try-a-push">3.1.2.2 is <code>6f</code> a <code>mov</code>, <code>push</code> or a <code>call</code>. Let's try a <code>push</code></a></h3>
<pre><code class="language-powershell">rasm2 -a x86 -b 32 &quot;push 0x12345678&quot;
6878563412
</code></pre>
<pre><code class="language-powershell">$text = &quot;38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487&quot; ; $text = $text -replace &quot;6f&quot;,&quot;68&quot;
rasm2 -a x86 -b 32 -D $text
0x00000000   2                     38c7  cmp bh, al
0x00000002   1                       57  push edi
0x00000003   5               6869687a68  push 0x687a6869
0x00000008   5               6869707536  push 0x36757069
0x0000000d   5               6836363636  push 0x36363636
0x00000012   1                       90  nop
0x00000013   7           ea5790e95a90e8  ljmp 0xe890:0x5ae99057
0x0000001a   2                     b712  mov bh, 0x12
0x0000001c   2                     d487  aam 0x87
</code></pre>
<p>Seems more than likely possible. We remember the values <code>0x687a6869</code>, <code>0x36757069</code> and <code>0x36363636</code> as data for future analysis.</p>
<h3 id="3131-is-90-a-mov-push-or-a-call-lets-try-a-push"><a class="header" href="#3131-is-90-a-mov-push-or-a-call-lets-try-a-push">3.1.3.1 is <code>90</code> a <code>mov</code>, <code>push</code> or a <code>call</code>. Let's try a <code>push</code>.</a></h3>
<pre><code class="language-powershell">rasm2 -a x86 -b 32 &quot;mov eax, eax&quot;
89c0
</code></pre>
<pre><code class="language-powershell">$text = &quot;38c7576f69687a6f6f697075366f3636363690ea5790e95a90e8b712d487&quot; ;
$text = $text -replace &quot;6f&quot;,&quot;68&quot;
$text = $text -replace &quot;90&quot;,&quot;89&quot;
rasm2 -a x86 -b 32 -D $text
0x00000000   2                     38c7  cmp bh, al
0x00000002   1                       57  push edi
0x00000003   5               6869687a68  push 0x687a6869
0x00000008   5               6869707536  push 0x36757069
0x0000000d   5               6836363636  push 0x36363636
0x00000012   2                     89ea  mov edx, ebp
0x00000014   1                       57  push edi
0x00000015   2                     89e9  mov ecx, ebp
0x00000017   1                       5a  pop edx
0x00000018   2                     89e8  mov eax, ebp
0x0000001a   2                     b712  mov bh, 0x12
0x0000001c   2                     d487  aam 0x87
</code></pre>
<p>The shellcode sample is too little... We can not go more far...</p>
<h3 id="32-caesar-brute-force"><a class="header" href="#32-caesar-brute-force">3.2 Caesar brute force</a></h3>
<p>After reverse engineering of the shellcode decryptror, we now know that the encryption algorithm is caesar. So let's implement a brute forcer to decrypt caesar algorithm.</p>
<p>The real challenge is, how to detect plain text x86 32 bits opcodes?</p>
<p>The first idea is to disassemble the code and see if no instruction is invalid. Sadly this method is not perfect. the 8051 has 255 instructions! Even this x86_32 sample encrypted shellcode has not any invalid instruction.</p>
<p>Whe can then combine it to two tools:
1- the frequency analysis as previously seen. The idea is to see if the decrypted opcodes have the same repartition as plain text.
2- the coincidence index. Same concept but also considere the repartition with the previous instructions.</p>
<pre><code class="language-powershell">cargo new caesar_shellcode_2_caesar_brute_forcer
</code></pre>
<p>Cargo.toml</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;caesar_shellcode_2_caesar_brute_forcer&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
cryptatools-core = { git = &quot;https://github.com/gogo2464/cryptatools-rs&quot;, package = 'cryptatools-core' }
serde_json = &quot;1.0.91&quot;
r2pipe = { git = &quot;https://github.com/RHL120/r2pipe.rs&quot;, branch = &quot;windows_bad&quot; }
itertools = &quot;0.10.5&quot;
<span class="boring">}</span></code></pre></pre>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust">use r2pipe::R2Pipe;
use r2pipe::open_pipe;
use cryptatools_core::utils::alphabets::Alphabet;
use cryptatools_core::cryptanalysis::general_cryptanalysis_methods::frequency_analysis::distribution_algorithms::statistical::Statistical;
use cryptatools_core::cryptography::classical::encryption::monoalphabetic_ciphers::caesar_number::CaesarNumberAlgorithm;
use std::u8;
use std::fmt::Write;

fn read_plain_text(cipher_text: String) -&gt; Vec&lt;u8&gt; {
  let mut bytes = Vec::new();
  for o in (0..cipher_text.len()).step_by(2) {
	let left = cipher_text.chars().nth(o).unwrap();
	let right = cipher_text.chars().nth(o+1).unwrap();
	let mut opcode = String::from(left);
	opcode.push(right);
	bytes.push(u8::from_str_radix(&amp;opcode, 16).unwrap());
  }	
  
  bytes
}

fn convert_u8_to_text(u8_vector: Vec&lt;u8&gt;) -&gt; String {
  let mut string = String::new();
  for num in u8_vector {
	if num &gt;= 0x0f {
		write!(&amp;mut string, &quot;{num:x}&quot;);
	} else {
		write!(&amp;mut string, &quot;0{num:x}&quot;);
	}
  }
  
  string
}

fn is_plain_text(probably_cipher_text: Vec&lt;u8&gt;) -&gt; bool {
	  let mut r2p = open_pipe!(Some(&quot;-&quot;)).unwrap();
	  
	  r2p.cmd(&quot;e anal.arch=x86 ; e asm.bits=32 ;&quot;).unwrap();
	  
	  let string_probably_cipher_text = convert_u8_to_text(probably_cipher_text.clone());
	  let mut cmd = String::from(&quot;&quot;);
	  write!(&amp;mut cmd, &quot;wx {string_probably_cipher_text} ;&quot;);
	  
	  r2p.cmd(&amp;cmd).unwrap();
	  let instructions = String::from(r2p.cmd(&quot;pI 0x1e @ 0x00 ;&quot;).unwrap());
	  
	  println!(&quot;instructions: {:?}&quot;, instructions);
	  
	  if instructions.find(&quot;invalid&quot;).is_none() == false {
		return false;  
	  }
	
	  let unknow_opcode_alphabet = Alphabet::new_empty().unknow_opcodes();
	  let stat = Statistical::new(unknow_opcode_alphabet.clone());
	  let stat_percentage = stat.guess_statistical_distribution(probably_cipher_text);
	  
	  for character in stat_percentage {
		  for opcode in character.0 {
			  println!(&quot;opcode {:x}, statistic: {:?}&quot;, opcode, character.1);
			  if opcode == 0x89 &amp;&amp; character.1 &gt; 20.0/100.0 &amp;&amp; character.1 &lt; 40.0/100.0 { //mov
			      return false;
		      }
		  }
	  }
	  
	  true
}

fn main() {
  let mut r2p = open_pipe!(Some(&quot;bin&quot;)).unwrap();
  let mut cipher_text = String::from(r2p.cmd(&quot;p8 0x1e @ 0x2c ;&quot;).unwrap());
  cipher_text.remove(cipher_text.len()-1);
  cipher_text.remove(cipher_text.len()-1);
  
  println!(&quot;cipher text: {:?}&quot;, cipher_text);
  
  let unknow_opcode_alphabet = Alphabet::new_empty().unknow_opcodes();
  let bytes = read_plain_text(cipher_text);
  let c = CaesarNumberAlgorithm::new(unknow_opcode_alphabet.into());
  let mut key = 0;
  let mut plain_text_found = false;
  let is_decrypted = c.decrypt_by_opcode_shift(bytes, key);
  key += 1;
  while plain_text_found == false {
	  let is_decrypted = c.decrypt_by_opcode_shift(is_decrypted.clone(), key);
	  plain_text_found = is_plain_text(is_decrypted.clone());
	  if plain_text_found == true {
		  break;
      }
	  key += 1;
  }
  
  println!(&quot;plain text:  {:?} decrypted with key {:?}&quot;, is_decrypted, key);
  r2p.close();
}```


## 3.3 Caesar breaking using reverse engineering analaysis and implementing a decryptor with cryptatools.

Now, let's determine the algorithm using reverse engineering method!

Sometimes assembly language could be hard to read and reverse due to counter-reverse engineering protections. It was not the case of this protection. Then let's continue to dig the reverse engineering.

```assembly
decode:
    cmp byte [esi], 7
    jl lowbound
    sub byte [esi], 7
    jmp 0x22
lowbound:
    xor ebx, ebx
    xor edx, edx
    mov bl, 7
    mov dl, 0xff
    inc dx
    sub bl, byte [esi]
    sub dx, bx
    mov byte [esi], dl
common_command:
    inc esi
    loop 7</code></pre></pre>
<p>After the reverse engineering, we already know that the caesar key is 7 from the instruction <code>loop 7</code>. Let's create a decryptor from cryptatools.</p>
<pre><code class="language-shell">cargo new caesar_shellcode_decryptor ;
cd caesar_shellcode_decryptor ;
</code></pre>
<p>Let's edit the <code>Cargo.toml</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[package]
name = &quot;caesar_shellcode_decryptor&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

<span class="boring">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</span>
[dependencies]
cryptatools-core = { git = &quot;https://github.com/gogo2464/cryptatools-rs&quot;, package = 'cryptatools-core' }
serde_json = &quot;1.0.91&quot;
r2pipe = { git = &quot;https://github.com/RHL120/r2pipe.rs&quot;, branch = &quot;windows_bad&quot; }
itertools = &quot;0.10.5&quot;
<span class="boring">}</span></code></pre></pre>
<p>Now edit the <code>main.rs</code></p>
<pre><pre class="playground"><code class="language-rust">use r2pipe::R2Pipe;
use r2pipe::open_pipe;
use cryptatools_core::cryptography::classical::encryption::monoalphabetic_ciphers::caesar_number::CaesarNumberAlgorithm;
use cryptatools_core::utils::alphabets::Alphabet;
use std::u8;
use itertools::Itertools;
use std::fmt::Write;

fn read_plain_text(cipher_text: String) -&gt; Vec&lt;u8&gt; {
  let mut bytes = Vec::new();
  for o in (0..cipher_text.len()).step_by(2) {
	let left = cipher_text.chars().nth(o).unwrap();
	let right = cipher_text.chars().nth(o+1).unwrap();
	let mut opcode = String::from(left);
	opcode.push(right);
	bytes.push(u8::from_str_radix(&amp;opcode, 16).unwrap());
  }	
  
  bytes
}


fn main() {
  let mut r2p = open_pipe!(Some(&quot;bin&quot;)).unwrap();
  let mut cipher_text = String::from(r2p.cmd(&quot;p8 0x1e @ 0x2c ;&quot;).unwrap());
  cipher_text.remove(cipher_text.len()-1);
  cipher_text.remove(cipher_text.len()-1);
  
  println!(&quot;cipher text: {:?}&quot;, cipher_text);
  
  let unknow_opcode_alphabet = Alphabet::new_empty().unknow_opcodes();
  let mut c: CaesarNumberAlgorithm = CaesarNumberAlgorithm::new(unknow_opcode_alphabet.into());
  
  let bytes = read_plain_text(cipher_text);
  let decrypted = c.decrypt_by_opcode_shift(bytes, 7);

  let mut string = String::new();
  for num in decrypted {
	if num &gt;= 0x0f {
		write!(&amp;mut string, &quot;{num:x}&quot;);
	} else {
		write!(&amp;mut string, &quot;0{num:x}&quot;);
	}
  }
  
  println!(&quot;plain text : {:?}&quot;, string);
  
  r2p.close();
}</code></pre></pre>
<pre><code class="language-shell">$ rasm2 -a x86 -b 32 -D &quot;31c05068626173686862696e2f682f2f2f2f89e35089e25389e1b00bcd80&quot;
0x00000000   2                     31c0  xor eax, eax
0x00000002   1                       50  push eax
0x00000003   5               6862617368  push 0x68736162
0x00000008   5               6862696e2f  push 0x2f6e6962
0x0000000d   5               682f2f2f2f  push 0x2f2f2f2f
0x00000012   2                     89e3  mov ebx, esp
0x00000014   1                       50  push eax
0x00000015   2                     89e2  mov edx, esp
0x00000017   1                       53  push ebx
0x00000018   2                     89e1  mov ecx, esp
0x0000001a   2                     b00b  mov al, 0xb
0x0000001c   2                     cd80  int 0x80
&gt; radare2 --
 -- In radare we trust
[0x00000000]&gt; ? 0x68736162
segment 6873000:6162
string  &quot;bash&quot;
[0x00000000]&gt; ? 0x2f6e6962
string  &quot;bin/&quot;
[0x00000000]&gt; ? 0x2f2f2f2f
string  &quot;////&quot;
</code></pre>
<h3 id="34-caesar-breaking-using-only-reverse-engineering-analaysis-by-debugging-no-cryptanalysis"><a class="header" href="#34-caesar-breaking-using-only-reverse-engineering-analaysis-by-debugging-no-cryptanalysis">3.4 Caesar breaking using only reverse engineering analaysis by debugging. No cryptanalysis.</a></h3>
<p>In this part we are going to debug the full shellcode in order to decrypt it. We need to have a Linux OS now.</p>
<pre><code class="language-shell">radare2 -a x86 -b 32 -e esil.romem=true -e emu.write=true -e io.cache=true -s 0x0 -c &quot;aei; aeip; aeim 0xffffd000 0x2000 stack; aesu 0x25; Vp&quot; bin
</code></pre>
<pre><code class="language-shell">&gt; i | grep size
size     0x4a
&gt; pI 0x4a @ 0x00
jmp 0x27
pop esi
xor ecx, ecx
mov cl, 0x1e
cmp byte [esi], 7
jl 0x11
sub byte [esi], 7
jmp 0x22
xor ebx, ebx
xor edx, edx
mov bl, 7
mov dl, 0xff
inc dx
sub bl, byte [esi]
sub dx, bx
mov byte [esi], dl
inc esi
loop 7
jmp 0x2c
call 2
xor eax, eax
push eax
push 0x68736162
push 0x2f6e6962
push 0x2f2f2f2f
mov ebx, esp
push eax
mov edx, esp
push ebx
mov ecx, esp
mov al, 0xb
int 0x80
</code></pre>
<p>The decrypted shellcode:</p>
<pre><code class="language-shell">xor eax, eax
push eax
push 0x68736162
push 0x2f6e6962
push 0x2f2f2f2f
mov ebx, esp
push eax
mov edx, esp
push ebx
mov ecx, esp
mov al, 0xb
int 0x80
</code></pre>
<p>absolutely correspond to what we found using cryptanalysis!!!</p>
<h3 id="4-conclusion"><a class="header" href="#4-conclusion">4 Conclusion</a></h3>
<p>Break caesar algorithm with statistic is trivial on plain text. It is different when the executables are encrypted because we have to deal with the opcode encryption as well as detect plain text assembly languages. Trough in this case, the esiest way was to implement a decryptor after reverse engineering the key, it is sometimes impossible in the case of a malware that deletes the key or provide access to the key only from a remote server that could be disconnected.</p>
<p>Hopefully, the byte parsing system of <code>cryptatools</code> allow to run cryptanalysis attack against these bytes as well as recognize plain text from bytes.</p>
<p>Once the plain text is found, we could use <code>radare2</code> emulation to emulate and run a single function: the one with plain text opcodes.</p>
<h3 id="sources-and-references"><a class="header" href="#sources-and-references">Sources and references</a></h3>
<p><a href="https://nasmland645.wordpress.com/2015/02/08/assignment-4-custom-shellcode-encoder/">Shellcode coding tutorial</a></p>
<p><a href="http://shell-storm.org/shellcode/files/shellcode-900.html">Shellstorm shellcode sample</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="evaluating-ethereum-address-collision-probabilities-with-birthday-paradox-method-using-ether-rs-and-cryptatools-rs"><a class="header" href="#evaluating-ethereum-address-collision-probabilities-with-birthday-paradox-method-using-ether-rs-and-cryptatools-rs">Evaluating Ethereum address collision probabilities with birthday paradox method using ether-rs and cryptatools-rs</a></h2>
<h1 id="i---intro-and-challenges"><a class="header" href="#i---intro-and-challenges">I - Intro And Challenges</a></h1>
<h1 id="1-intro"><a class="header" href="#1-intro">1. Intro</a></h1>
<p>Ethereum is a decentralized cryptocurrency. Each people has his own wallet authenticated with a public/private keyset. As ethereum is decentralized, if someone create the adress of somebody else, then he will be able to spoof his identity. Hopefully addresses are random, then we need to create a lot of identities.</p>
<p>But how many identities do we need to create? A paper at this address <a href="https://download.wpsoftware.net/bitcoin-birthday.pdf">here</a> has already answered to this question.</p>
<p>Today we are going to implement a cryptanalys attack with <code>cryptatools</code> to automatically know the attempts required instead of calculating manually.</p>
<h1 id="2-challenges-and-terms"><a class="header" href="#2-challenges-and-terms">2. Challenges And Terms</a></h1>
<p>In the origin, the Birtday Paradox Attack is an attack where the attackant wants to check if the has output is tall enough hash output in order to find collision using pure brute force.
It is effective in web2 hashing algorithm in order to know if collision are possible on hash algorithm.
This attack supposes that the hash output generation is purely perfectly random. Tough this methd seems very very brute, the birtday paradox uses math probabilities in order to evaluate if a hash outpute is long enough.</p>
<p>Today we are going to implement a birtday paradox evalution on bitcoin cryptocurrency using cryptatools-rs, we are able to use birtday paradox, not in order to run hash attack but to evalutate how many time we will need to try in order to have 50% of chances to reach a collision between two wallets.</p>
<h1 id="ii-lets-do-it"><a class="header" href="#ii-lets-do-it">II let's do it</a></h1>
<h1 id="1-fecthing-a-random-author-adress"><a class="header" href="#1-fecthing-a-random-author-adress">1. Fecthing A Random Author Adress</a></h1>
<p>We need to fetch a random hash in order to check if the hash is strong enough. We will use the library <code>ether-rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ethers::prelude::*;
<span class="boring">}</span></code></pre></pre>
<p>then let's use it in order to really fetch the block:</p>
<pre><pre class="playground"><code class="language-rust">use ethers::prelude::*;

const WSS_URL: &amp;str = &quot;wss://mainnet.infura.io/ws/v3/c60b0bb42f8a4c6481ecd229eddaca27&quot;;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {    
    let provider = Provider::&lt;Ws&gt;::connect(WSS_URL).await?;
    let mut stream = provider.subscribe_blocks().await?.take(1);
    let mut wallet_block: Option&lt;Vec&lt;u8&gt;&gt; = None;
    while let Some(block) = stream.next().await {
        if let Some(author) = block.author {
            wallet_block = Some(author.0.to_vec());

            println!(&quot;random hash author: {:?}&quot;, author);
        }
    }

    Ok(())
}</code></pre></pre>
<h1 id="2-configuring-cryptatools-rs"><a class="header" href="#2-configuring-cryptatools-rs">2. Configuring cryptatools-rs</a></h1>
<p>In <code>cryptatools-rs</code>, the alphabet is a concept that applies not only for letters but also to any format. We need to tells cryptatools-rs to use hexadecimal alphabet because it will calculate the length in bits of the alphabet in order to occur the birthday paradox with the right number of bits.</p>
<p>We need to select the alphabet. We will use <code>full_hexadecimal_alphabet</code> struct because it is a struct that contains 255 values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hexadecimal_alphabet = Alphabet::new_empty().full_hexadecimal_alphabet();
let mut bp = BirtdayParadox::new(hexadecimal_alphabet.into());
<span class="boring">}</span></code></pre></pre>
<p>Now we will need to call the method <code>calculate_birtday_paradox_expecting_percent_focusing_on_speed_with_taylor</code>.</p>
<p>This is a method that is speed enough to be calculated on more than let's say 10 characters hash. This is sadly less precise than the method  <code>calculate_birtday_paradox_expecting_percent_focusing_on_precision</code> that we will not user here.</p>
<p>Let's write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bp.calculate_birtday_paradox_expecting_percent_focusing_on_speed_with_taylor(target_hash.clone(), 0.50)
<span class="boring">}</span></code></pre></pre>
<p>in</p>
<pre><pre class="playground"><code class="language-rust">use ethers::prelude::*;

use cryptatools_core::utils::{convert::Encode, alphabets::split_bytes_by_characters_representation, alphabets::Alphabet, alphabets::Encoding};
use cryptatools_core::cryptanalysis::general_cryptanalysis_methods::frequency_analysis::coincidence_index::CoincidenceIndexGuesser;
use cryptatools_core::cryptanalysis::general_cryptanalysis_methods::hash_cryptanalysis::birthday_paradox::BirtdayParadox;

const WSS_URL: &amp;str = &quot;wss://mainnet.infura.io/ws/v3/c60b0bb42f8a4c6481ecd229eddaca27&quot;;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    let hexadecimal_alphabet = Alphabet::new_empty().full_hexadecimal_alphabet();
    let bp = BirtdayParadox::new(hexadecimal_alphabet.into());
    
    let provider = Provider::&lt;Ws&gt;::connect(WSS_URL).await?;
    let mut stream = provider.subscribe_blocks().await?.take(1);
    let mut wallet_block: Option&lt;Vec&lt;u8&gt;&gt; = None;
    while let Some(block) = stream.next().await {
        if let Some(author) = block.author {
            wallet_block = Some(author.0.to_vec());
        }
    }

    if let Some(wallet_block) = wallet_block {
        let target_hash = wallet_block;
        println!(&quot;after {:?} attempts, there is 50% of chances to get a collision on ethereum addresses.&quot;, bp.calculate_birtday_paradox_expecting_percent_focusing_on_speed_with_taylor(target_hash.clone(), 0.50));
    } else {
        println!(&quot;Error: wallet not found. Check your internet connection.&quot;);
    }

    Ok(())
}</code></pre></pre>
<h1 id="4-running-a-birtday-paradox-evaluation"><a class="header" href="#4-running-a-birtday-paradox-evaluation">4. Running a Birtday paradox evaluation.</a></h1>
<p>In the paper they mentionned:</p>
<pre><code>For e = 50%, this gives n = 1.41  10^24.
</code></pre>
<p>Let's run...</p>
<pre><code>After 1.4234013764919992e24 attempts, there is 50% of chances to get a collision on ethereum addresses.
</code></pre>
<p>Sounds perfect! It is exactly the same answer than the paper!</p>
<p>Of course there is a difference of 0.01e24 but the birthday paradox is an approximation.</p>
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>ethereum wallet hash and alphabet length provide same resistance as the bitcoin.</p>
<p>We do not have to worry about the probability to find a wallet collision. It is very safe!</p>
<div style="break-before: page; page-break-before: always;"></div><p>The project <code>cryptatools-core</code> is a well documented project. Each element of the library should have been documented in the API documentation.</p>
<ul>
<li><a href="https://gogo2464.github.io/cryptatools-rs/cryptatools_core/index.html">See the API Reference at this address: API-Ref</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-doing-cryptanalysis"><a class="header" href="#why-doing-cryptanalysis">Why Doing Cryptanalysis</a></h1>
<h2 id="1---what-is-cryptanalysis"><a class="header" href="#1---what-is-cryptanalysis">1 - What Is Cryptanalysis?</a></h2>
<p>Cryptography is a way to make an information impossible to understand from an attackant (generally not legitimate to read the information) that wants to read it.</p>
<p>Cryptography is often done by compagnies or end users who wants to protect these informations such as password, private conversation out of scope of an adversarial spy.</p>
<p>Cryptanalysis is then the method to break cryptographic algorithm.</p>
<h2 id="2---goals-of-cryptanalysis"><a class="header" href="#2---goals-of-cryptanalysis">2 - Goals Of Cryptanalysis</a></h2>
<p>Sometimes, the person who wants to read information is not illegitimate.</p>
<h2 id="21-malware-analysis"><a class="header" href="#21-malware-analysis">2.1 Malware Analysis</a></h2>
<h3 id="211---ransomware-decryption"><a class="header" href="#211---ransomware-decryption">2.1.1 - Ransomware Decryption</a></h3>
<p>It could be the case if an hacker has encrypted computer files of a compagny in order to ask for a ransom. If the files are still present on the disk, then the cyber security analyst could make reverse engineering of the ransomware executable to determine the encryption algorithm and then write a script with <code>cryptatools-rs</code> in order to attack the encryption algoritm of the malware to decrypt the encrypted files of the victim with no paying the ransom to the malicious hacker.</p>
<h3 id="212---antivirus-updating"><a class="header" href="#212---antivirus-updating">2.1.2 - Antivirus Updating</a></h3>
<p>Malware are malicious softwares errorly know as &quot;virus&quot; (as virus designated more specific malware that necessaily spreads over files).</p>
<p>Sometimes malwares are encrypted. It could be done by malicious malware writter to bypass the anti-virus or in order to stop a malware analyst to know how the malware works to stop the anti-virus developper from updating the anti virus.</p>
<h2 id="22-bug-bounty-and-pentest"><a class="header" href="#22-bug-bounty-and-pentest">2.2 Bug Bounty And Pentest</a></h2>
<h2 id="221-bug-bounty"><a class="header" href="#221-bug-bounty">2.2.1 Bug Bounty</a></h2>
<p>Softwares need to use encryption to stop an attackant to listen to them. They may use Bug Bounty to ask searchers to find vulnerabilities and reward them legally to fix them. It is a way to proove the security of a software openly to users.</p>
<p>Some are:</p>
<ul>
<li><a href="https://immunefi.com/">immunify</a></li>
<li><a href="https://www.zerodayinitiative.com/">zero day initiative</a></li>
</ul>
<h3 id="2211-on-network-encryption"><a class="header" href="#2211-on-network-encryption">2.2.1.1 On Network Encryption</a></h3>
<p>When network is intercepted on the wifi/4G/5G or any way, you could try to code cryptanalysis exploits on software encryption in order to decipher traffic.</p>
<h3 id="2212-on-blockchain"><a class="header" href="#2212-on-blockchain">2.2.1.2 On Blockchain</a></h3>
<p>There could be huge vulnerabilities on the blockchain if the blockchain is not codded correctly. As example:</p>
<ul>
<li>If the hash algorithm contains collisions, we could forge a fake signature and take over any account of the blockchain and steal all the money.</li>
<li>If a bad random number generator is present on the blockchain, we could guess all the RSA private key of any future users. It implies that we could steal all their money.</li>
<li>And so on...</li>
</ul>
<p>See <a href="https://github.com/slowmist/Cryptocurrency-Security-Audit-Guide/blob/main/Blockchain-Common-Vulnerability-List.md#encryption">this reference</a> to have a non exhaustive list of blockchain possible cyber attacks.</p>
<h3 id="222-pentest"><a class="header" href="#222-pentest">2.2.2 Pentest</a></h3>
<p>Once an exploit is Public or has been reached by your pentest compagny, you can use it after having signed a contract in order to secure the compagny from cyber attacks. This process is know as pentest.</p>
<p>In the case of a pentest, each cryptanalysis exploit could be used to proove the lack of security of a network.</p>
<h2 id="23-cryptographic-research"><a class="header" href="#23-cryptographic-research">2.3 Cryptographic Research</a></h2>
<p>In order to test a cryptographic algorithm, if you are researcher, you could need to test your cryptographic/cryptanalytic algorithm.</p>
<h2 id="24---secrets-agencies"><a class="header" href="#24---secrets-agencies">2.4 - Secrets Agencies</a></h2>
<p>Each modern gouvernement use hacking as cyberwar method today. They may use electronic war method forbidden in the civil that we will not discuss here in order to steal information to other governments to watch them and prevent economical or militiry war. So even the most offensive cryptanalysis method could be done for them. This may include:</p>
<ul>
<li>Listenning to encrypted wifi over a hacked wifi (example cache poisonning).</li>
<li>Listenning to 4/5G in order to interecept encrypted communication of smart phones.</li>
</ul>
<p>Even if you have no contract with compagny, you can sell your exploit to a reseller of your governemental secret agency legally with zerodium.</p>
<p><a href="https://zerodium.com/">zerodium</a> is a kind of bug bounty platform for zero day exploit. Zerodium will exploit the vulnerability instead of fix it.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
