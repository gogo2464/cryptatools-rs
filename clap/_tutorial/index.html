<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Documentation: Builder Tutorial"><title>clap::_tutorial - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../static.files/ayu-be46fdc453a55015.css"><script src="../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../clap/index.html"><img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../clap/index.html">
                <img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></a><h2 class="location"><a href="#">Module _tutorial</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">clap</a>::<wbr><a class="mod" href="#">_tutorial</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/clap/_tutorial.rs.html#10-222">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="documentation-builder-tutorial"><a href="#documentation-builder-tutorial">Documentation: Builder Tutorial</a></h2>
<ol>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#configuring-the-parser">Configuring the Parser</a></li>
<li><a href="#adding-arguments">Adding Arguments</a>
<ol>
<li><a href="#positionals">Positionals</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#flags">Flags</a></li>
<li><a href="#subcommands">Subcommands</a></li>
<li><a href="#defaults">Defaults</a></li>
</ol>
</li>
<li>Validation
<ol>
<li><a href="#enumerated-values">Enumerated values</a></li>
<li><a href="#validated-values">Validated values</a></li>
<li><a href="#argument-relations">Argument Relations</a></li>
<li><a href="#custom-validation">Custom Validation</a></li>
</ol>
</li>
<li><a href="#testing">Testing</a></li>
</ol>
<p>See also</p>
<ul>
<li><a href="../_faq/index.html#when-should-i-use-the-builder-vs-derive-apis" title="mod clap::_faq">FAQ: When should I use the builder vs derive APIs?</a></li>
<li>The <a href="../_derive/_cookbook/index.html" title="mod clap::_derive::_cookbook">cookbook</a> for more application-focused examples</li>
</ul>
<h3 id="quick-start"><a href="#quick-start">Quick Start</a></h3>
<p>You can create an application with several arguments using usage strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::{arg, command, value_parser, ArgAction, Command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(<span class="macro">arg!</span>([name] <span class="string">&quot;Optional name to operate on&quot;</span>))
        .arg(
            <span class="macro">arg!</span>(
                -c --config &lt;FILE&gt; <span class="string">&quot;Sets a custom config file&quot;
            </span>)
            <span class="comment">// We don&#39;t have syntax yet for optional options, so manually calling `required`
            </span>.required(<span class="bool-val">false</span>)
            .value_parser(<span class="macro">value_parser!</span>(PathBuf)),
        )
        .arg(<span class="macro">arg!</span>(
            -d --debug ... <span class="string">&quot;Turn debugging information on&quot;
        </span>))
        .subcommand(
            Command::new(<span class="string">&quot;test&quot;</span>)
                .about(<span class="string">&quot;does testing things&quot;</span>)
                .arg(<span class="macro">arg!</span>(-l --list <span class="string">&quot;lists test values&quot;</span>).action(ArgAction::SetTrue)),
        )
        .get_matches();

    <span class="comment">// You can check the value provided by positional arguments, or option arguments
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(name) = matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>) {
        <span class="macro">println!</span>(<span class="string">&quot;Value for name: {}&quot;</span>, name);
    }

    <span class="kw">if let </span><span class="prelude-val">Some</span>(config_path) = matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;config&quot;</span>) {
        <span class="macro">println!</span>(<span class="string">&quot;Value for config: {}&quot;</span>, config_path.display());
    }

    <span class="comment">// You can see how many times a particular flag or argument occurred
    // Note, only flags can have multiple occurrences
    </span><span class="kw">match </span>matches
        .get_one::&lt;u8&gt;(<span class="string">&quot;debug&quot;</span>)
        .expect(<span class="string">&quot;Count&#39;s are defaulted&quot;</span>)
    {
        <span class="number">0 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is off&quot;</span>),
        <span class="number">1 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is kind of on&quot;</span>),
        <span class="number">2 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is on&quot;</span>),
        <span class="kw">_ </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Don&#39;t be crazy&quot;</span>),
    }

    <span class="comment">// You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(matches) = matches.subcommand_matches(<span class="string">&quot;test&quot;</span>) {
        <span class="comment">// &quot;$ myapp test&quot; was run
        </span><span class="kw">if </span>matches.get_flag(<span class="string">&quot;list&quot;</span>) {
            <span class="comment">// &quot;$ myapp test -l&quot; was run
            </span><span class="macro">println!</span>(<span class="string">&quot;Printing testing lists...&quot;</span>);
        } <span class="kw">else </span>{
            <span class="macro">println!</span>(<span class="string">&quot;Not printing testing lists...&quot;</span>);
        }
    }

    <span class="comment">// Continued program logic goes here...
</span>}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 01_quick[EXE] [OPTIONS] [name] [COMMAND]

Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [name]  Optional name to operate on

Options:
  -c, --config &lt;FILE&gt;  Sets a custom config file
  -d, --debug...       Turn debugging information on
  -h, --help           Print help
  -V, --version        Print version

</code></pre></div>
<p>By default, the program does nothing:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick
Debug mode is off

</code></pre></div>
<p>But you can mix and match the various features</p>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick -dd test
Debug mode is on
Not printing testing lists...

</code></pre></div><h3 id="configuring-the-parser"><a href="#configuring-the-parser">Configuring the Parser</a></h3>
<p>You use <a href="../builder/struct.Command.html" title="struct clap::builder::Command"><code>Command</code></a> to start building a parser.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, Command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = Command::new(<span class="string">&quot;MyApp&quot;</span>)
        .version(<span class="string">&quot;1.0&quot;</span>)
        .author(<span class="string">&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;</span>)
        .about(<span class="string">&quot;Does awesome things&quot;</span>)
        .arg(<span class="macro">arg!</span>(--two &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .arg(<span class="macro">arg!</span>(--one &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;two: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;two&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
    <span class="macro">println!</span>(
        <span class="string">&quot;one: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;one&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_apps --help
Does awesome things

Usage: 02_apps[EXE] --two &lt;VALUE&gt; --one &lt;VALUE&gt;

Options:
      --two &lt;VALUE&gt;  
      --one &lt;VALUE&gt;  
  -h, --help         Print help
  -V, --version      Print version

$ 02_apps --version
MyApp 1.0

</code></pre></div>
<p>You can use <a href="../macro.command.html" title="macro clap::command"><code>command!()</code></a> to fill these fields in from your <code>Cargo.toml</code>
file.  <strong>This requires the <a href="../_features/index.html" title="mod clap::_features"><code>cargo</code> feature flag</a>.</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command};

<span class="kw">fn </span>main() {
    <span class="comment">// requires `cargo` feature, reading name, version, author, and description from `Cargo.toml`
    </span><span class="kw">let </span>matches = <span class="macro">command!</span>()
        .arg(<span class="macro">arg!</span>(--two &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .arg(<span class="macro">arg!</span>(--one &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;two: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;two&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
    <span class="macro">println!</span>(
        <span class="string">&quot;one: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;one&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_crate --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_crate[EXE] --two &lt;VALUE&gt; --one &lt;VALUE&gt;

Options:
      --two &lt;VALUE&gt;  
      --one &lt;VALUE&gt;  
  -h, --help         Print help
  -V, --version      Print version

$ 02_crate --version
clap [..]

</code></pre></div>
<p>You can use <a href="../builder/struct.Command.html" title="struct clap::builder::Command"><code>Command</code></a> methods to change the application level behavior of
clap.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.next_line_help(<span class="bool-val">true</span>)
        .arg(<span class="macro">arg!</span>(--two &lt;VALUE&gt;).required(<span class="bool-val">true</span>).action(ArgAction::Set))
        .arg(<span class="macro">arg!</span>(--one &lt;VALUE&gt;).required(<span class="bool-val">true</span>).action(ArgAction::Set))
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;two: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;two&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
    <span class="macro">println!</span>(
        <span class="string">&quot;one: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;one&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_app_settings --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_app_settings[EXE] --two &lt;VALUE&gt; --one &lt;VALUE&gt;

Options:
      --two &lt;VALUE&gt;
          
      --one &lt;VALUE&gt;
          
  -h, --help
          Print help
  -V, --version
          Print version

</code></pre></div><h3 id="adding-arguments"><a href="#adding-arguments">Adding Arguments</a></h3><h4 id="positionals"><a href="#positionals">Positionals</a></h4>
<p>You can have users specify values by their position on the command-line:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(Arg::new(<span class="string">&quot;name&quot;</span>))
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_03_positional --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional[EXE] [name]

Arguments:
  [name]  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_03_positional
name: None

$ 03_03_positional bob
name: Some(&quot;bob&quot;)

</code></pre></div>
<p>Note that the default <a href="../builder/enum.ArgAction.html" title="enum clap::builder::ArgAction"><code>ArgAction</code></a> is <a href="../builder/enum.ArgAction.html#variant.Set" title="variant clap::builder::ArgAction::Set"><code>Set</code></a>.  To
accept multiple values, use <a href="../builder/enum.ArgAction.html#variant.Append" title="variant clap::builder::ArgAction::Append"><code>Append</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(Arg::new(<span class="string">&quot;name&quot;</span>).action(ArgAction::Append))
        .get_matches();

    <span class="kw">let </span>args = matches
        .get_many::&lt;String&gt;(<span class="string">&quot;name&quot;</span>)
        .unwrap_or_default()
        .map(|v| v.as_str())
        .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

    <span class="macro">println!</span>(<span class="string">&quot;names: {:?}&quot;</span>, <span class="kw-2">&amp;</span>args);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_03_positional_mult --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_mult[EXE] [name]...

Arguments:
  [name]...  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_03_positional_mult
names: []

$ 03_03_positional_mult bob
names: [&quot;bob&quot;]

$ 03_03_positional_mult bob john
names: [&quot;bob&quot;, &quot;john&quot;]

</code></pre></div><h4 id="options"><a href="#options">Options</a></h4>
<p>You can name your arguments with a flag:</p>
<ul>
<li>Order doesn’t matter</li>
<li>They can be optional</li>
<li>Intent is clearer</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(Arg::new(<span class="string">&quot;name&quot;</span>).short(<span class="string">&#39;n&#39;</span>).long(<span class="string">&quot;name&quot;</span>))
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_02_option --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option[EXE] [OPTIONS]

Options:
  -n, --name &lt;name&gt;  
  -h, --help         Print help
  -V, --version      Print version

$ 03_02_option
name: None

$ 03_02_option --name bob
name: Some(&quot;bob&quot;)

$ 03_02_option --name=bob
name: Some(&quot;bob&quot;)

$ 03_02_option -n bob
name: Some(&quot;bob&quot;)

$ 03_02_option -n=bob
name: Some(&quot;bob&quot;)

$ 03_02_option -nbob
name: Some(&quot;bob&quot;)

</code></pre></div>
<p>Note that the default <a href="../builder/enum.ArgAction.html" title="enum clap::builder::ArgAction"><code>ArgAction</code></a> is <a href="../builder/enum.ArgAction.html#variant.Set" title="variant clap::builder::ArgAction::Set"><code>Set</code></a>.  To
accept multiple occurrences, use <a href="../builder/enum.ArgAction.html#variant.Append" title="variant clap::builder::ArgAction::Append"><code>Append</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            Arg::new(<span class="string">&quot;name&quot;</span>)
                .short(<span class="string">&#39;n&#39;</span>)
                .long(<span class="string">&quot;name&quot;</span>)
                .action(ArgAction::Append),
        )
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_02_option_mult --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_mult[EXE] [OPTIONS]

Options:
  -n, --name &lt;name&gt;  
  -h, --help         Print help
  -V, --version      Print version

$ 03_02_option_mult
name: None

$ 03_02_option_mult --name bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult --name=bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult -n bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult -n=bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult -nbob
name: Some(&quot;bob&quot;)

</code></pre></div><h4 id="flags"><a href="#flags">Flags</a></h4>
<p>Flags can also be switches that can be on/off:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            Arg::new(<span class="string">&quot;verbose&quot;</span>)
                .short(<span class="string">&#39;v&#39;</span>)
                .long(<span class="string">&quot;verbose&quot;</span>)
                .action(ArgAction::SetTrue),
        )
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;verbose: {:?}&quot;</span>, matches.get_flag(<span class="string">&quot;verbose&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_01_flag_bool --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_bool[EXE] [OPTIONS]

Options:
  -v, --verbose  
  -h, --help     Print help
  -V, --version  Print version

$ 03_01_flag_bool
verbose: false

$ 03_01_flag_bool --verbose
verbose: true

$ 03_01_flag_bool --verbose --verbose
? failed
error: the argument &#39;--verbose&#39; cannot be used multiple times

Usage: 03_01_flag_bool[EXE] [OPTIONS]

For more information, try &#39;--help&#39;.

</code></pre></div>
<p>To accept multiple flags, use <a href="../builder/enum.ArgAction.html#variant.Count" title="variant clap::builder::ArgAction::Count"><code>Count</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            Arg::new(<span class="string">&quot;verbose&quot;</span>)
                .short(<span class="string">&#39;v&#39;</span>)
                .long(<span class="string">&quot;verbose&quot;</span>)
                .action(ArgAction::Count),
        )
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;verbose: {:?}&quot;</span>, matches.get_count(<span class="string">&quot;verbose&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_01_flag_count --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_count[EXE] [OPTIONS]

Options:
  -v, --verbose...  
  -h, --help        Print help
  -V, --version     Print version

$ 03_01_flag_count
verbose: 0

$ 03_01_flag_count --verbose
verbose: 1

$ 03_01_flag_count --verbose --verbose
verbose: 2

</code></pre></div><h4 id="subcommands"><a href="#subcommands">Subcommands</a></h4>
<p>Subcommands are defined as <a href="../builder/struct.Command.html" title="struct clap::builder::Command"><code>Command</code></a>s that get added via
<a href="../builder/struct.Command.html#method.subcommand" title="method clap::builder::Command::subcommand"><code>Command::subcommand</code></a>. Each instance of a Subcommand can have its
own version, author(s), Args, and even its own subcommands.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, Command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.propagate_version(<span class="bool-val">true</span>)
        .subcommand_required(<span class="bool-val">true</span>)
        .arg_required_else_help(<span class="bool-val">true</span>)
        .subcommand(
            Command::new(<span class="string">&quot;add&quot;</span>)
                .about(<span class="string">&quot;Adds files to myapp&quot;</span>)
                .arg(<span class="macro">arg!</span>([NAME])),
        )
        .get_matches();

    <span class="kw">match </span>matches.subcommand() {
        <span class="prelude-val">Some</span>((<span class="string">&quot;add&quot;</span>, sub_matches)) =&gt; <span class="macro">println!</span>(
            <span class="string">&quot;&#39;myapp add&#39; was used, name is: {:?}&quot;</span>,
            sub_matches.get_one::&lt;String&gt;(<span class="string">&quot;NAME&quot;</span>)
        ),
        <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;Exhausted list of subcommands and subcommand_required prevents `None`&quot;</span>),
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands[EXE] &lt;COMMAND&gt;

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_04_subcommands help add
Adds files to myapp

Usage: 03_04_subcommands[EXE] add [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_04_subcommands add bob
&#39;myapp add&#39; was used, name is: Some(&quot;bob&quot;)

</code></pre></div>
<p>Because we set <a href="../builder/struct.Command.html#method.arg_required_else_help" title="method clap::builder::Command::arg_required_else_help"><code>Command::arg_required_else_help</code></a>:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands
? failed
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands[EXE] &lt;COMMAND&gt;

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

</code></pre></div>
<p>Because we set <a href="../builder/struct.Command.html#method.propagate_version" title="method clap::builder::Command::propagate_version"><code>Command::propagate_version</code></a>:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands --version
clap [..]

$ 03_04_subcommands add --version
clap-add [..]

</code></pre></div><h4 id="defaults"><a href="#defaults">Defaults</a></h4>
<p>We’ve previously showed that arguments can be <a href="../builder/struct.Arg.html#method.required" title="method clap::builder::Arg::required"><code>required</code></a> or optional.
When optional, you work with a <code>Option</code> and can <code>unwrap_or</code>.  Alternatively, you can set
<a href="../builder/struct.Arg.html#method.default_value" title="method clap::builder::Arg::default_value"><code>Arg::default_value</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, value_parser};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>([PORT])
                .value_parser(<span class="macro">value_parser!</span>(u16))
                .default_value(<span class="string">&quot;2020&quot;</span>),
        )
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;port: {:?}&quot;</span>,
        matches
            .get_one::&lt;u16&gt;(<span class="string">&quot;PORT&quot;</span>)
            .expect(<span class="string">&quot;default ensures there is always a value&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_05_default_values --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_05_default_values[EXE] [PORT]

Arguments:
  [PORT]  [default: 2020]

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_05_default_values
port: 2020

$ 03_05_default_values 22
port: 22

</code></pre></div><h3 id="validation"><a href="#validation">Validation</a></h3>
<p>By default, arguments are assumed to be <code>String</code>s and only UTF-8 validation is performed.</p>
<h4 id="enumerated-values"><a href="#enumerated-values">Enumerated values</a></h4>
<p>If you have arguments of specific values you want to test for, you can use the
<a href="../builder/struct.PossibleValuesParser.html" title="struct clap::builder::PossibleValuesParser"><code>PossibleValuesParser</code></a> or <a href="../builder/struct.Arg.html#method.value_parser" title="method clap::builder::Arg::value_parser"><code>Arg::value_parser([&quot;val1&quot;, ...])</code></a> for short.</p>
<p>This allows you specify the valid values for that argument. If the user does not use one of
those specific values, they will receive a graceful exit with error message informing them
of the mistake, and what the possible valid values are</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;MODE&gt;)
                .help(<span class="string">&quot;What mode to run the program in&quot;</span>)
                .value_parser([<span class="string">&quot;fast&quot;</span>, <span class="string">&quot;slow&quot;</span>]),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">match </span>matches
        .get_one::&lt;String&gt;(<span class="string">&quot;MODE&quot;</span>)
        .expect(<span class="string">&quot;&#39;MODE&#39; is required and parsing will fail if its missing&quot;</span>)
        .as_str()
    {
        <span class="string">&quot;fast&quot; </span>=&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Hare&quot;</span>);
        }
        <span class="string">&quot;slow&quot; </span>=&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Tortoise&quot;</span>);
        }
        <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_01_possible --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_possible[EXE] &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_01_possible fast
Hare

$ 04_01_possible slow
Tortoise

$ 04_01_possible medium
? failed
error: invalid value &#39;medium&#39; for &#39;&lt;MODE&gt;&#39;
  [possible values: fast, slow]

For more information, try &#39;--help&#39;.

</code></pre></div>
<p>When enabling the <a href="../_features/index.html" title="mod clap::_features"><code>derive</code> feature</a>, you can use
<a href="../trait.ValueEnum.html" title="trait clap::ValueEnum"><code>ValueEnum</code></a> to take care of the boiler plate for you, giving the same
results.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, builder::PossibleValue, command, value_parser, ValueEnum};

<span class="attr">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
</span><span class="kw">enum </span>Mode {
    Fast,
    Slow,
}

<span class="comment">// Can also be derived with feature flag `derive`
</span><span class="kw">impl </span>ValueEnum <span class="kw">for </span>Mode {
    <span class="kw">fn </span>value_variants&lt;<span class="lifetime">&#39;a</span>&gt;() -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[<span class="self">Self</span>] {
        <span class="kw-2">&amp;</span>[Mode::Fast, Mode::Slow]
    }

    <span class="kw">fn </span>to_possible_value&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;PossibleValue&gt; {
        <span class="prelude-val">Some</span>(<span class="kw">match </span><span class="self">self </span>{
            Mode::Fast =&gt; PossibleValue::new(<span class="string">&quot;fast&quot;</span>).help(<span class="string">&quot;Run swiftly&quot;</span>),
            Mode::Slow =&gt; PossibleValue::new(<span class="string">&quot;slow&quot;</span>).help(<span class="string">&quot;Crawl slowly but steadily&quot;</span>),
        })
    }
}

<span class="kw">impl </span>std::fmt::Display <span class="kw">for </span>Mode {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>std::fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; std::fmt::Result {
        <span class="self">self</span>.to_possible_value()
            .expect(<span class="string">&quot;no values are skipped&quot;</span>)
            .get_name()
            .fmt(f)
    }
}

<span class="kw">impl </span>std::str::FromStr <span class="kw">for </span>Mode {
    <span class="kw">type </span><span class="prelude-val">Err </span>= String;

    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="kw">for </span>variant <span class="kw">in </span><span class="self">Self</span>::value_variants() {
            <span class="kw">if </span>variant.to_possible_value().unwrap().matches(s, <span class="bool-val">false</span>) {
                <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="kw-2">*</span>variant);
            }
        }
        <span class="prelude-val">Err</span>(<span class="macro">format!</span>(<span class="string">&quot;invalid variant: {}&quot;</span>, s))
    }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;MODE&gt;)
                .help(<span class="string">&quot;What mode to run the program in&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(Mode)),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">match </span>matches
        .get_one::&lt;Mode&gt;(<span class="string">&quot;MODE&quot;</span>)
        .expect(<span class="string">&quot;&#39;MODE&#39; is required and parsing will fail if its missing&quot;</span>)
    {
        Mode::Fast =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Hare&quot;</span>);
        }
        Mode::Slow =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Tortoise&quot;</span>);
        }
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_01_enum --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum[EXE] &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;
          What mode to run the program in

          Possible values:
          - fast: Run swiftly
          - slow: Crawl slowly but steadily

Options:
  -h, --help
          Print help (see a summary with &#39;-h&#39;)

  -V, --version
          Print version

$ 04_01_enum -h
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum[EXE] &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help (see more with &#39;--help&#39;)
  -V, --version  Print version

$ 04_01_enum fast
Hare

$ 04_01_enum slow
Tortoise

$ 04_01_enum medium
? failed
error: invalid value &#39;medium&#39; for &#39;&lt;MODE&gt;&#39;
  [possible values: fast, slow]

For more information, try &#39;--help&#39;.

</code></pre></div><h4 id="validated-values"><a href="#validated-values">Validated values</a></h4>
<p>More generally, you can validate and parse into any data type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, value_parser};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;PORT&gt;)
                .help(<span class="string">&quot;Network port to use&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(u16).range(<span class="number">1</span>..)),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">let </span>port: u16 = <span class="kw-2">*</span>matches
        .get_one::&lt;u16&gt;(<span class="string">&quot;PORT&quot;</span>)
        .expect(<span class="string">&quot;&#39;PORT&#39; is required and parsing will fail if its missing&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, port);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_02_parse --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_parse[EXE] &lt;PORT&gt;

Arguments:
  &lt;PORT&gt;  Network port to use

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_02_parse 22
PORT = 22

$ 04_02_parse foobar
? failed
error: invalid value &#39;foobar&#39; for &#39;&lt;PORT&gt;&#39;: invalid digit found in string

For more information, try &#39;--help&#39;.

$ 04_02_parse_derive 0
? failed
error: invalid value &#39;0&#39; for &#39;&lt;PORT&gt;&#39;: 0 is not in 1..=65535

For more information, try &#39;--help&#39;.

</code></pre></div>
<p>A custom parser can be used to improve the error messages or provide additional validation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ops::RangeInclusive;

<span class="kw">use </span>clap::{arg, command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;PORT&gt;)
                .help(<span class="string">&quot;Network port to use&quot;</span>)
                .value_parser(port_in_range),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">let </span>port: u16 = <span class="kw-2">*</span>matches
        .get_one::&lt;u16&gt;(<span class="string">&quot;PORT&quot;</span>)
        .expect(<span class="string">&quot;&#39;PORT&#39; is required and parsing will fail if its missing&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, port);
}

<span class="kw">const </span>PORT_RANGE: RangeInclusive&lt;usize&gt; = <span class="number">1</span>..=<span class="number">65535</span>;

<span class="kw">fn </span>port_in_range(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;u16, String&gt; {
    <span class="kw">let </span>port: usize = s
        .parse()
        .map_err(|<span class="kw">_</span>| <span class="macro">format!</span>(<span class="string">&quot;`{}` isn&#39;t a port number&quot;</span>, s))<span class="question-mark">?</span>;
    <span class="kw">if </span>PORT_RANGE.contains(<span class="kw-2">&amp;</span>port) {
        <span class="prelude-val">Ok</span>(port <span class="kw">as </span>u16)
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(<span class="macro">format!</span>(
            <span class="string">&quot;port not in range {}-{}&quot;</span>,
            PORT_RANGE.start(),
            PORT_RANGE.end()
        ))
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_02_validate --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_validate[EXE] &lt;PORT&gt;

Arguments:
  &lt;PORT&gt;  Network port to use

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_02_validate 22
PORT = 22

$ 04_02_validate foobar
? failed
error: invalid value &#39;foobar&#39; for &#39;&lt;PORT&gt;&#39;: `foobar` isn&#39;t a port number

For more information, try &#39;--help&#39;.

$ 04_02_validate 0
? failed
error: invalid value &#39;0&#39; for &#39;&lt;PORT&gt;&#39;: port not in range 1-65535

For more information, try &#39;--help&#39;.

</code></pre></div>
<p>See <a href="../builder/struct.Arg.html#method.value_parser" title="method clap::builder::Arg::value_parser"><code>Arg::value_parser</code></a> for more details.</p>
<h4 id="argument-relations"><a href="#argument-relations">Argument Relations</a></h4>
<p>You can declare dependencies or conflicts between <a href="../builder/struct.Arg.html" title="struct clap::builder::Arg"><code>Arg</code></a>s or even
<a href="../builder/struct.ArgGroup.html" title="struct clap::builder::ArgGroup"><code>ArgGroup</code></a>s.</p>
<p><a href="../builder/struct.ArgGroup.html" title="struct clap::builder::ArgGroup"><code>ArgGroup</code></a>s  make it easier to declare relations instead of having to list
each individually, or when you want a rule to apply “any but not all” arguments.</p>
<p>Perhaps the most common use of <a href="../builder/struct.ArgGroup.html" title="struct clap::builder::ArgGroup"><code>ArgGroup</code></a>s is to require one and <em>only</em> one
argument to be present out of a given set. Imagine that you had multiple arguments, and you
want one of them to be required, but making all of them required isn’t feasible because perhaps
they conflict with each other.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::{arg, command, value_parser, ArgAction, ArgGroup};

<span class="kw">fn </span>main() {
    <span class="comment">// Create application like normal
    </span><span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        // Add the version arguments
        </span>.arg(<span class="macro">arg!</span>(--<span class="string">&quot;set-ver&quot; </span>&lt;VER&gt; <span class="string">&quot;set version manually&quot;</span>))
        .arg(<span class="macro">arg!</span>(--major         <span class="string">&quot;auto inc major&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--minor         <span class="string">&quot;auto inc minor&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--patch         <span class="string">&quot;auto inc patch&quot;</span>).action(ArgAction::SetTrue))
        <span class="comment">// Create a group, make it required, and add the above arguments
        </span>.group(
            ArgGroup::new(<span class="string">&quot;vers&quot;</span>)
                .required(<span class="bool-val">true</span>)
                .args([<span class="string">&quot;set-ver&quot;</span>, <span class="string">&quot;major&quot;</span>, <span class="string">&quot;minor&quot;</span>, <span class="string">&quot;patch&quot;</span>]),
        )
        <span class="comment">// Arguments can also be added to a group individually, these two arguments
        // are part of the &quot;input&quot; group which is not required
        </span>.arg(
            <span class="macro">arg!</span>([INPUT_FILE] <span class="string">&quot;some regular input&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf))
                .group(<span class="string">&quot;input&quot;</span>),
        )
        .arg(
            <span class="macro">arg!</span>(--<span class="string">&quot;spec-in&quot; </span>&lt;SPEC_IN&gt; <span class="string">&quot;some special input argument&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf))
                .group(<span class="string">&quot;input&quot;</span>),
        )
        <span class="comment">// Now let&#39;s assume we have a -c [config] argument which requires one of
        // (but **not** both) the &quot;input&quot; arguments
        </span>.arg(
            <span class="macro">arg!</span>(config: -c &lt;CONFIG&gt;)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf))
                .requires(<span class="string">&quot;input&quot;</span>),
        )
        .get_matches();

    <span class="comment">// Let&#39;s assume the old version 1.2.3
    </span><span class="kw">let </span><span class="kw-2">mut </span>major = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>minor = <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>patch = <span class="number">3</span>;

    <span class="comment">// See if --set-ver was used to set the version manually
    </span><span class="kw">let </span>version = <span class="kw">if let </span><span class="prelude-val">Some</span>(ver) = matches.get_one::&lt;String&gt;(<span class="string">&quot;set-ver&quot;</span>) {
        ver.to_owned()
    } <span class="kw">else </span>{
        <span class="comment">// Increment the one requested (in a real program, we&#39;d reset the lower numbers)
        </span><span class="kw">let </span>(maj, min, pat) = (
            matches.get_flag(<span class="string">&quot;major&quot;</span>),
            matches.get_flag(<span class="string">&quot;minor&quot;</span>),
            matches.get_flag(<span class="string">&quot;patch&quot;</span>),
        );
        <span class="kw">match </span>(maj, min, pat) {
            (<span class="bool-val">true</span>, <span class="kw">_</span>, <span class="kw">_</span>) =&gt; major += <span class="number">1</span>,
            (<span class="kw">_</span>, <span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; minor += <span class="number">1</span>,
            (<span class="kw">_</span>, <span class="kw">_</span>, <span class="bool-val">true</span>) =&gt; patch += <span class="number">1</span>,
            <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
        };
        <span class="macro">format!</span>(<span class="string">&quot;{}.{}.{}&quot;</span>, major, minor, patch)
    };

    <span class="macro">println!</span>(<span class="string">&quot;Version: {}&quot;</span>, version);

    <span class="comment">// Check for usage of -c
    </span><span class="kw">if </span>matches.contains_id(<span class="string">&quot;config&quot;</span>) {
        <span class="kw">let </span>input = matches
            .get_one::&lt;PathBuf&gt;(<span class="string">&quot;INPUT_FILE&quot;</span>)
            .unwrap_or_else(|| matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;spec-in&quot;</span>).unwrap())
            .display();
        <span class="macro">println!</span>(
            <span class="string">&quot;Doing work using input {} and config {}&quot;</span>,
            input,
            matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;config&quot;</span>).unwrap().display()
        );
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_03_relations --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_03_relations[EXE] [OPTIONS] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver &lt;VER&gt;      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in &lt;SPEC_IN&gt;  some special input argument
  -c &lt;CONFIG&gt;              
  -h, --help               Print help
  -V, --version            Print version

$ 04_03_relations
? failed
error: the following required arguments were not provided:
  &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt;

Usage: 04_03_relations[EXE] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

For more information, try &#39;--help&#39;.

$ 04_03_relations --major
Version: 2.2.3

$ 04_03_relations --major --minor
? failed
error: the argument &#39;--major&#39; cannot be used with &#39;--minor&#39;

Usage: 04_03_relations[EXE] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

For more information, try &#39;--help&#39;.

$ 04_03_relations --major -c config.toml
? failed
error: the following required arguments were not provided:
  &lt;INPUT_FILE|--spec-in &lt;SPEC_IN&gt;&gt;

Usage: 04_03_relations[EXE] -c &lt;CONFIG&gt; &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; &lt;INPUT_FILE|--spec-in &lt;SPEC_IN&gt;&gt;

For more information, try &#39;--help&#39;.

$ 04_03_relations --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml

</code></pre></div><h4 id="custom-validation"><a href="#custom-validation">Custom Validation</a></h4>
<p>As a last resort, you can create custom errors with the basics of clap’s formatting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::error::ErrorKind;
<span class="kw">use </span>clap::{arg, command, value_parser, ArgAction};

<span class="kw">fn </span>main() {
    <span class="comment">// Create application like normal
    </span><span class="kw">let </span><span class="kw-2">mut </span>cmd = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        // Add the version arguments
        </span>.arg(<span class="macro">arg!</span>(--<span class="string">&quot;set-ver&quot; </span>&lt;VER&gt; <span class="string">&quot;set version manually&quot;</span>))
        .arg(<span class="macro">arg!</span>(--major         <span class="string">&quot;auto inc major&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--minor         <span class="string">&quot;auto inc minor&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--patch         <span class="string">&quot;auto inc patch&quot;</span>).action(ArgAction::SetTrue))
        <span class="comment">// Arguments can also be added to a group individually, these two arguments
        // are part of the &quot;input&quot; group which is not required
        </span>.arg(<span class="macro">arg!</span>([INPUT_FILE] <span class="string">&quot;some regular input&quot;</span>).value_parser(<span class="macro">value_parser!</span>(PathBuf)))
        .arg(
            <span class="macro">arg!</span>(--<span class="string">&quot;spec-in&quot; </span>&lt;SPEC_IN&gt; <span class="string">&quot;some special input argument&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf)),
        )
        <span class="comment">// Now let&#39;s assume we have a -c [config] argument which requires one of
        // (but **not** both) the &quot;input&quot; arguments
        </span>.arg(<span class="macro">arg!</span>(config: -c &lt;CONFIG&gt;).value_parser(<span class="macro">value_parser!</span>(PathBuf)));
    <span class="kw">let </span>matches = cmd.get_matches_mut();

    <span class="comment">// Let&#39;s assume the old version 1.2.3
    </span><span class="kw">let </span><span class="kw-2">mut </span>major = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>minor = <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>patch = <span class="number">3</span>;

    <span class="comment">// See if --set-ver was used to set the version manually
    </span><span class="kw">let </span>version = <span class="kw">if let </span><span class="prelude-val">Some</span>(ver) = matches.get_one::&lt;String&gt;(<span class="string">&quot;set-ver&quot;</span>) {
        <span class="kw">if </span>matches.get_flag(<span class="string">&quot;major&quot;</span>) || matches.get_flag(<span class="string">&quot;minor&quot;</span>) || matches.get_flag(<span class="string">&quot;patch&quot;</span>) {
            cmd.error(
                ErrorKind::ArgumentConflict,
                <span class="string">&quot;Can&#39;t do relative and absolute version change&quot;</span>,
            )
            .exit();
        }
        ver.to_string()
    } <span class="kw">else </span>{
        <span class="comment">// Increment the one requested (in a real program, we&#39;d reset the lower numbers)
        </span><span class="kw">let </span>(maj, min, pat) = (
            matches.get_flag(<span class="string">&quot;major&quot;</span>),
            matches.get_flag(<span class="string">&quot;minor&quot;</span>),
            matches.get_flag(<span class="string">&quot;patch&quot;</span>),
        );
        <span class="kw">match </span>(maj, min, pat) {
            (<span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">false</span>) =&gt; major += <span class="number">1</span>,
            (<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>) =&gt; minor += <span class="number">1</span>,
            (<span class="bool-val">false</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>) =&gt; patch += <span class="number">1</span>,
            <span class="kw">_ </span>=&gt; {
                cmd.error(
                    ErrorKind::ArgumentConflict,
                    <span class="string">&quot;Can only modify one version field&quot;</span>,
                )
                .exit();
            }
        };
        <span class="macro">format!</span>(<span class="string">&quot;{}.{}.{}&quot;</span>, major, minor, patch)
    };

    <span class="macro">println!</span>(<span class="string">&quot;Version: {}&quot;</span>, version);

    <span class="comment">// Check for usage of -c
    </span><span class="kw">if </span>matches.contains_id(<span class="string">&quot;config&quot;</span>) {
        <span class="kw">let </span>input = matches
            .get_one::&lt;PathBuf&gt;(<span class="string">&quot;INPUT_FILE&quot;</span>)
            .or_else(|| matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;spec-in&quot;</span>))
            .unwrap_or_else(|| {
                cmd.error(
                    ErrorKind::MissingRequiredArgument,
                    <span class="string">&quot;INPUT_FILE or --spec-in is required when using --config&quot;</span>,
                )
                .exit()
            })
            .display();
        <span class="macro">println!</span>(
            <span class="string">&quot;Doing work using input {} and config {}&quot;</span>,
            input,
            matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;config&quot;</span>).unwrap().display()
        );
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_04_custom --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver &lt;VER&gt;      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in &lt;SPEC_IN&gt;  some special input argument
  -c &lt;CONFIG&gt;              
  -h, --help               Print help
  -V, --version            Print version

$ 04_04_custom
? failed
error: Can only modify one version field

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information, try &#39;--help&#39;.

$ 04_04_custom --major
Version: 2.2.3

$ 04_04_custom --major --minor
? failed
error: Can only modify one version field

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information, try &#39;--help&#39;.

$ 04_04_custom --major -c config.toml
? failed
Version: 2.2.3
error: INPUT_FILE or --spec-in is required when using --config

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information, try &#39;--help&#39;.

$ 04_04_custom --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml

</code></pre></div><h3 id="testing"><a href="#testing">Testing</a></h3>
<p>clap reports most development errors as <code>debug_assert!</code>s.  Rather than checking every
subcommand, you should have a test that calls
<a href="../builder/struct.Command.html#method.debug_assert" title="method clap::builder::Command::debug_assert"><code>Command::debug_assert</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, value_parser};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = cmd().get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">let </span>port: usize = <span class="kw-2">*</span>matches
        .get_one::&lt;usize&gt;(<span class="string">&quot;PORT&quot;</span>)
        .expect(<span class="string">&quot;&#39;PORT&#39; is required and parsing will fail if its missing&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, port);
}

<span class="kw">fn </span>cmd() -&gt; clap::Command {
    <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;PORT&gt;)
                .help(<span class="string">&quot;Network port to use&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(usize)),
        )
}

<span class="attr">#[test]
</span><span class="kw">fn </span>verify_cmd() {
    cmd().debug_assert();
}</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="clap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (f63ccaf25 2023-03-06)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>