<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="1. What does this library do?"><meta name="keywords" content="rust, rustlang, rust-lang, lingua"><title>lingua - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../lingua/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../lingua/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate lingua</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.4.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">lingua</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/lingua/lib.rs.html#17-303">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h3 id="1-what-does-this-library-do"><a href="#1-what-does-this-library-do">1. What does this library do?</a></h3>
<p>Its task is simple: It tells you which language some provided textual data is written in.
This is very useful as a preprocessing step for linguistic data in natural language
processing applications such as text classification and spell checking.
Other use cases, for instance, might include routing e-mails to the right geographically
located customer service department, based on the e-mails’ languages.</p>
<h3 id="2-why-does-this-library-exist"><a href="#2-why-does-this-library-exist">2. Why does this library exist?</a></h3>
<p>Language detection is often done as part of large machine learning frameworks or natural
language processing applications. In cases where you don’t need the full-fledged
functionality of those systems or don’t want to learn the ropes of those,
a small flexible library comes in handy.</p>
<p>So far, the only other comprehensive open source libraries in the Rust ecosystem for
this task are <a href="https://github.com/emk/rust-cld2"><em>CLD2</em></a>
and <a href="https://github.com/greyblake/whatlang-rs"><em>Whatlang</em></a>.
Unfortunately, they have two major drawbacks:</p>
<ol>
<li>Detection only works with quite lengthy text fragments. For very short text snippets
such as Twitter messages, it does not provide adequate results.</li>
<li>The more languages take part in the decision process, the less accurate are the
detection results.</li>
</ol>
<p><em>Lingua</em> aims at eliminating these problems. It nearly does not need any configuration and
yields pretty accurate results on both long and short text, even on single words and phrases.
It draws on both rule-based and statistical methods but does not use any dictionaries of words.
It does not need a connection to any external API or service either.
Once the library has been downloaded, it can be used completely offline.</p>
<h3 id="3-which-languages-are-supported"><a href="#3-which-languages-are-supported">3. Which languages are supported?</a></h3>
<p>Compared to other language detection libraries, <em>Lingua’s</em> focus is on <em>quality over quantity</em>,
that is, getting detection right for a small set of languages first before adding new ones.
Currently, 75 languages are supported. They are listed as variants in the <a href="enum.Language.html" title="Language">Language</a> enum.</p>
<h3 id="4-how-good-is-it"><a href="#4-how-good-is-it">4. How good is it?</a></h3>
<p><em>Lingua</em> is able to report accuracy statistics for some bundled test data available for each
supported language. The test data for each language is split into three parts:</p>
<ol>
<li>a list of single words with a minimum length of 5 characters</li>
<li>a list of word pairs with a minimum length of 10 characters</li>
<li>a list of complete grammatical sentences of various lengths</li>
</ol>
<p>Both the language models and the test data have been created from separate documents of the
<a href="https://wortschatz.uni-leipzig.de">Wortschatz corpora</a> offered by Leipzig University, Germany.
Data crawled from various news websites have been used for training, each corpus comprising one
million sentences. For testing, corpora made of arbitrarily chosen websites have been used,
each comprising ten thousand sentences. From each test corpus, a random unsorted subset of
1000 single words, 1000 word pairs and 1000 sentences has been extracted, respectively.</p>
<p>Given the generated test data, I have compared the detection results of <em>Lingua</em>, <em>CLD2</em> and
<em>Whatlang</em> running over the data of <em>Lingua’s</em> supported 75 languages. Languages that are not
supported by <em>Whatlang</em> are simply ignored for this library during the detection process.</p>
<p>The <a href="https://github.com/pemistahl/lingua-rs/blob/main/ACCURACY_PLOTS.md">bar and box plots</a>
show the measured accuracy values for all three performed tasks: Single word detection,
word pair detection and sentence detection. <em>Lingua</em> clearly outperforms its contenders.
Detailed statistics including mean, median and standard deviation values for each language
and classifier are available in
<a href="https://github.com/pemistahl/lingua-rs/blob/main/ACCURACY_TABLE.md">tabular form</a> as well.</p>
<h3 id="5-why-is-it-better-than-other-libraries"><a href="#5-why-is-it-better-than-other-libraries">5. Why is it better than other libraries?</a></h3>
<p>Every language detector uses a probabilistic <a href="https://en.wikipedia.org/wiki/N-gram">n-gram</a>
model trained on the character distribution in some training corpus. Most libraries only use
n-grams of size 3 (trigrams) which is satisfactory for detecting the language of longer text
fragments consisting of multiple sentences. For short phrases or single words, however,
trigrams are not enough. The shorter the input text is, the less n-grams are available.
The probabilities estimated from such few n-grams are not reliable. This is why <em>Lingua</em> makes
use of n-grams of sizes 1 up to 5 which results in much more accurate prediction of the correct
language.</p>
<p>A second important difference is that <em>Lingua</em> does not only use such a statistical model, but
also a rule-based engine. This engine first determines the alphabet of the input text and
searches for characters which are unique in one or more languages. If exactly one language can
be reliably chosen this way, the statistical model is not necessary anymore. In any case, the
rule-based engine filters out languages that do not satisfy the conditions of the input text.
Only then, in a second step, the probabilistic n-gram model is taken into consideration.
This makes sense because loading less language models means less memory consumption and better
runtime performance.</p>
<p>In general, it is always a good idea to restrict the set of languages to be considered in the
classification process using the respective api methods. If you know beforehand that certain
languages are never to occur in an input text, do not let those take part in the classifcation
process. The filtering mechanism of the rule-based engine is quite good, however, filtering
based on your own knowledge of the input text is always preferable.</p>
<h3 id="6-how-to-add-it-to-your-project"><a href="#6-how-to-add-it-to-your-project">6. How to add it to your project?</a></h3>
<p>Add <em>Lingua</em> to your <code>Cargo.toml</code> file like so:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
lingua = &quot;1.4.0&quot;
</code></pre></div>
<p>By default, this will download the language model dependencies for all 75 supported languages,
a total of approximately 100 MB. If your bandwidth or hard drive space is limited, or you simply
do not need all languages, you can specify a subset of the language models to be downloaded as
separate features in your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
lingua = { version = &quot;1.4.0&quot;, default-features = false, features = [&quot;french&quot;, &quot;italian&quot;, &quot;spanish&quot;] }
</code></pre></div><h3 id="7-how-to-use"><a href="#7-how-to-use">7. How to use?</a></h3><h4 id="71-basic-usage"><a href="#71-basic-usage">7.1 Basic usage</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lingua::{Language, LanguageDetector, LanguageDetectorBuilder};
<span class="kw">use </span>lingua::Language::{English, French, German, Spanish};

<span class="kw">let </span>languages = <span class="macro">vec!</span>[English, French, German, Spanish];
<span class="kw">let </span>detector: LanguageDetector = LanguageDetectorBuilder::from_languages(<span class="kw-2">&amp;</span>languages).build();
<span class="kw">let </span>detected_language: <span class="prelude-ty">Option</span>&lt;Language&gt; = detector.detect_language_of(<span class="string">&quot;languages are awesome&quot;</span>);

<span class="macro">assert_eq!</span>(detected_language, <span class="prelude-val">Some</span>(English));</code></pre></div>
<h4 id="72-minimum-relative-distance"><a href="#72-minimum-relative-distance">7.2 Minimum relative distance</a></h4>
<p>By default, <em>Lingua</em> returns the most likely language for a given input text. However, there are
certain words that are spelled the same in more than one language. The word <em>prologue</em>, for
instance, is both a valid English and French word. <em>Lingua</em> would output either English or
French which might be wrong in the given context. For cases like that, it is possible to
specify a minimum relative distance that the logarithmized and summed up probabilities for
each possible language have to satisfy. It can be stated in the following way:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lingua::LanguageDetectorBuilder;
<span class="kw">use </span>lingua::Language::{English, French, German, Spanish};

<span class="kw">let </span>detector = LanguageDetectorBuilder::from_languages(<span class="kw-2">&amp;</span>[English, French, German, Spanish])
    .with_minimum_relative_distance(<span class="number">0.25</span>) <span class="comment">// minimum: 0.00 maximum: 0.99 default: 0.00
    </span>.build();
<span class="kw">let </span>detected_language = detector.detect_language_of(<span class="string">&quot;languages are awesome&quot;</span>);

<span class="macro">assert_eq!</span>(detected_language, <span class="prelude-val">None</span>);</code></pre></div>
<p>Be aware that the distance between the language probabilities is dependent on the length of the
input text. The longer the input text, the larger the distance between the languages. So if you
want to classify very short text phrases, do not set the minimum relative distance too high.
Otherwise <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None"><code>None</code></a> will be
returned most of the time as in the example above. This is the return value for cases where
language detection is not reliably possible.</p>
<h4 id="73-confidence-values"><a href="#73-confidence-values">7.3 Confidence values</a></h4>
<p>Knowing about the most likely language is nice but how reliable is the computed likelihood?
And how less likely are the other examined languages in comparison to the most likely one?
These questions can be answered as well:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lingua::{LanguageDetectorBuilder, Language};
<span class="kw">use </span>lingua::Language::{English, French, German, Spanish};
<span class="kw">use </span>float_cmp::approx_eq;

<span class="kw">let </span>languages = <span class="macro">vec!</span>[English, French, German, Spanish];
<span class="kw">let </span>detector = LanguageDetectorBuilder::from_languages(<span class="kw-2">&amp;</span>languages).build();
<span class="kw">let </span>confidence_values: Vec&lt;(Language, f64)&gt; = detector.compute_language_confidence_values(
    <span class="string">&quot;languages are awesome&quot;
</span>);

<span class="comment">// The more readable version of the assertions below:
// assert_eq!(
//     confidence_values,
//     vec![(English, 1.0), (French, 0.79), (German, 0.75), (Spanish, 0.72)]
// );

</span><span class="macro">assert_eq!</span>(confidence_values[<span class="number">0</span>], (English, <span class="number">1.0_f64</span>));

<span class="macro">assert_eq!</span>(confidence_values[<span class="number">1</span>].<span class="number">0</span>, French);
<span class="macro">assert!</span>(<span class="macro">approx_eq!</span>(f64, confidence_values[<span class="number">1</span>].<span class="number">1</span>, <span class="number">0.7917282993701181</span>, ulps = <span class="number">2</span>));

<span class="macro">assert_eq!</span>(confidence_values[<span class="number">2</span>].<span class="number">0</span>, German);
<span class="macro">assert!</span>(<span class="macro">approx_eq!</span>(f64, confidence_values[<span class="number">2</span>].<span class="number">1</span>, <span class="number">0.7532048914992281</span>, ulps = <span class="number">2</span>));

<span class="macro">assert_eq!</span>(confidence_values[<span class="number">3</span>].<span class="number">0</span>, Spanish);
<span class="macro">assert!</span>(<span class="macro">approx_eq!</span>(f64, confidence_values[<span class="number">3</span>].<span class="number">1</span>, <span class="number">0.7229637749926444</span>, ulps = <span class="number">2</span>));</code></pre></div>
<p>In the example above, a vector of all possible languages is returned, sorted by their confidence
value in descending order. The values that the detector computes are part of a <strong>relative</strong>
confidence metric, not of an absolute one. Each value is a number between 0.0 and 1.0.
The most likely language is always returned with value 1.0. All other languages get values
assigned which are lower than 1.0, denoting how less likely those languages are in comparison
to the most likely language.</p>
<p>The vector returned by this method does not necessarily contain all languages which the calling
instance of <a href="struct.LanguageDetector.html" title="LanguageDetector">LanguageDetector</a> was built from. If the rule-based engine decides that a specific
language is truly impossible, then it will not be part of the returned vector. Likewise, if no
ngram probabilities can be found within the detector’s languages for the given input text, the
returned vector will be empty. The confidence value for each language not being part of the
returned vector is assumed to be 0.0.</p>
<h4 id="74-eager-loading-versus-lazy-loading"><a href="#74-eager-loading-versus-lazy-loading">7.4 Eager loading versus lazy loading</a></h4>
<p>By default, <em>Lingua</em> uses lazy-loading to load only those language models on demand which are
considered relevant by the rule-based filter engine. For web services, for instance, it is
rather beneficial to preload all language models into memory to avoid unexpected latency while
waiting for the service response. If you want to enable the eager-loading mode, you can do it
like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lingua::LanguageDetectorBuilder;

LanguageDetectorBuilder::from_all_languages().with_preloaded_language_models().build();</code></pre></div>
<p>Multiple instances of <code>LanguageDetector</code> share the same language models in memory which are
accessed asynchronously by the instances.</p>
<h4 id="75-methods-to-build-the-languagedetector"><a href="#75-methods-to-build-the-languagedetector">7.5 Methods to build the LanguageDetector</a></h4>
<p>There might be classification tasks where you know beforehand that your language data is
definitely not written in Latin, for instance (what a surprise :-). The detection accuracy can
become better in such cases if you exclude certain languages from the decision process or just
explicitly include relevant languages:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lingua::{LanguageDetectorBuilder, Language, IsoCode639_1, IsoCode639_3};

<span class="comment">// Including all languages available in the library
// consumes approximately 2GB of memory and might
// lead to slow runtime performance.
</span>LanguageDetectorBuilder::from_all_languages();

<span class="comment">// Include only languages that are not yet extinct (= currently excludes Latin).
</span>LanguageDetectorBuilder::from_all_spoken_languages();

<span class="comment">// Include only languages written with Cyrillic script.
</span>LanguageDetectorBuilder::from_all_languages_with_cyrillic_script();

<span class="comment">// Exclude only the Spanish language from the decision algorithm.
</span>LanguageDetectorBuilder::from_all_languages_without(<span class="kw-2">&amp;</span>[Language::Spanish]);

<span class="comment">// Only decide between English and German.
</span>LanguageDetectorBuilder::from_languages(<span class="kw-2">&amp;</span>[Language::English, Language::German]);

<span class="comment">// Select languages by ISO 639-1 code.
</span>LanguageDetectorBuilder::from_iso_codes_639_1(<span class="kw-2">&amp;</span>[IsoCode639_1::EN, IsoCode639_1::DE]);

<span class="comment">// Select languages by ISO 639-3 code.
</span>LanguageDetectorBuilder::from_iso_codes_639_3(<span class="kw-2">&amp;</span>[IsoCode639_3::ENG, IsoCode639_3::DEU]);</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LanguageDetector.html" title="lingua::LanguageDetector struct">LanguageDetector</a></div><div class="item-right docblock-short">This struct detects the language of given input text.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LanguageDetectorBuilder.html" title="lingua::LanguageDetectorBuilder struct">LanguageDetectorBuilder</a></div><div class="item-right docblock-short">This struct configures and creates an instance of <a href="struct.LanguageDetector.html" title="LanguageDetector">LanguageDetector</a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LanguageModelFilesWriter.html" title="lingua::LanguageModelFilesWriter struct">LanguageModelFilesWriter</a></div><div class="item-right docblock-short">This struct creates language model files and writes them to a directory.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TestDataFilesWriter.html" title="lingua::TestDataFilesWriter struct">TestDataFilesWriter</a></div><div class="item-right docblock-short">This struct creates test data files for accuracy report generation
and writes them to a directory.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.IsoCode639_1.html" title="lingua::IsoCode639_1 enum">IsoCode639_1</a></div><div class="item-right docblock-short">This enum specifies the ISO 639-1 code representations for the supported languages.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.IsoCode639_3.html" title="lingua::IsoCode639_3 enum">IsoCode639_3</a></div><div class="item-right docblock-short">This enum specifies the ISO 639-3 code representations for the supported languages.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Language.html" title="lingua::Language enum">Language</a></div><div class="item-right docblock-short">This enum specifies the so far 75 supported languages which can be detected by <em>Lingua</em>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="lingua" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>